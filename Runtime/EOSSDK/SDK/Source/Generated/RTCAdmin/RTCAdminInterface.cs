// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.RTCAdmin
{
	public sealed partial class RTCAdminInterface : Handle
	{
		public RTCAdminInterface()
		{
		}

		public RTCAdminInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="CopyUserTokenByIndexOptions" /> struct.
		/// </summary>
		public const int COPYUSERTOKENBYINDEX_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="CopyUserTokenByUserIdOptions" /> struct.
		/// </summary>
		public const int COPYUSERTOKENBYUSERID_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="Kick" /> API
		/// </summary>
		public const int KICK_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="QueryJoinRoomToken" /> API
		/// </summary>
		public const int QUERYJOINROOMTOKEN_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="SetParticipantHardMuteOptions" /> struct.
		/// </summary>
		public const int SETPARTICIPANTHARDMUTE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="UserToken" /> struct.
		/// </summary>
		public const int USERTOKEN_API_LATEST = 1;

		/// <summary>
		/// Fetches a user token when called inside of the OnQueryJoinRoomTokenComplete callback.
		/// The order of the tokens doesn't necessarily match the order of the <see cref="ProductUserId" /> array specified in the <see cref="QueryJoinRoomTokenOptions" /> when
		/// initiating the query.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the index being accessed
		/// </param>
		/// <param name="outUserToken">
		/// The user token for the given index, if it exists and is valid. Use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserToken
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the user token is not found
		/// </returns>
		public Result CopyUserTokenByIndex(ref CopyUserTokenByIndexOptions options, out UserToken? outUserToken)
		{
			var optionsInternal = default(CopyUserTokenByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outUserTokenPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_RTCAdmin_CopyUserTokenByIndex(InnerHandle, ref optionsInternal, out outUserTokenPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<UserTokenInternal, UserToken>(outUserTokenPointer, out outUserToken);
			if (outUserTokenPointer != IntPtr.Zero)
			{
				Bindings.EOS_RTCAdmin_UserToken_Release(outUserTokenPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches a user token for a given user ID when called inside of the OnQueryJoinRoomTokenComplete callback.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the user ID being accessed
		/// </param>
		/// <param name="outUserToken">
		/// The user token for the given user ID, if it exists and is valid. Use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserToken
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the user token is not found
		/// </returns>
		public Result CopyUserTokenByUserId(ref CopyUserTokenByUserIdOptions options, out UserToken? outUserToken)
		{
			var optionsInternal = default(CopyUserTokenByUserIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outUserTokenPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_RTCAdmin_CopyUserTokenByUserId(InnerHandle, ref optionsInternal, out outUserTokenPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<UserTokenInternal, UserToken>(outUserTokenPointer, out outUserToken);
			if (outUserTokenPointer != IntPtr.Zero)
			{
				Bindings.EOS_RTCAdmin_UserToken_Release(outUserTokenPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Starts an asynchronous task that removes a participant from a room and revokes their token.
		/// </summary>
		/// <param name="options">
		/// structure containing the room and user to revoke the token from.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void Kick(ref KickOptions options, object clientData, OnKickCompleteCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(KickOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_RTCAdmin_Kick(InnerHandle, ref optionsInternal, clientDataPointer, OnKickCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Query for a list of user tokens for joining a room.
		/// 
		/// Each query generates a query id ( see <see cref="QueryJoinRoomTokenCompleteCallbackInfo" /> ) which should be used
		/// to retrieve the tokens from inside the callback.
		/// 
		/// This query id and query result itself are only valid for the duration of the callback.
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the application whose user tokens we're retrieving.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// This function is called when the query join room token operation completes.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public void QueryJoinRoomToken(ref QueryJoinRoomTokenOptions options, object clientData, OnQueryJoinRoomTokenCompleteCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryJoinRoomTokenOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_RTCAdmin_QueryJoinRoomToken(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryJoinRoomTokenCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Starts an asynchronous task remotely mutes/unmutes a room participant.
		/// 
		/// This remotely mutes the specified participant, so no audio is sent from that participant to any other participant in the room.
		/// </summary>
		/// <param name="options">
		/// structure containing the room and user to mute.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void SetParticipantHardMute(ref SetParticipantHardMuteOptions options, object clientData, OnSetParticipantHardMuteCompleteCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(SetParticipantHardMuteOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_RTCAdmin_SetParticipantHardMute(InnerHandle, ref optionsInternal, clientDataPointer, OnSetParticipantHardMuteCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}
	}
}

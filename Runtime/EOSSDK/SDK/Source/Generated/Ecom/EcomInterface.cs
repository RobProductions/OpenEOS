// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.Ecom
{
	public sealed partial class EcomInterface : Handle
	{
		public EcomInterface()
		{
		}

		public EcomInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="CatalogItem" /> struct.
		/// </summary>
		public const int CATALOGITEM_API_LATEST = 1;
		/// <summary>
		/// Timestamp value representing an undefined EntitlementEndTimestamp for <see cref="CatalogItem" />
		/// </summary>
		public const int CATALOGITEM_ENTITLEMENTENDTIMESTAMP_UNDEFINED = -1;
		/// <summary>
		/// The most recent version of the <see cref="CatalogOffer" /> struct.
		/// </summary>
		public const int CATALOGOFFER_API_LATEST = 5;
		/// <summary>
		/// Timestamp value representing an undefined EffectiveDateTimestamp for <see cref="CatalogOffer" />
		/// </summary>
		public const int CATALOGOFFER_EFFECTIVEDATETIMESTAMP_UNDEFINED = -1;
		/// <summary>
		/// Timestamp value representing an undefined ExpirationTimestamp for <see cref="CatalogOffer" />
		/// </summary>
		public const int CATALOGOFFER_EXPIRATIONTIMESTAMP_UNDEFINED = -1;
		/// <summary>
		/// Timestamp value representing an undefined ReleaseDateTimestamp for <see cref="CatalogOffer" />
		/// </summary>
		public const int CATALOGOFFER_RELEASEDATETIMESTAMP_UNDEFINED = -1;
		/// <summary>
		/// The most recent version of the <see cref="CatalogRelease" /> struct.
		/// </summary>
		public const int CATALOGRELEASE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CheckoutEntry" /> struct.
		/// </summary>
		public const int CHECKOUTENTRY_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="Checkout" /> API.
		/// </summary>
		public const int CHECKOUT_API_LATEST = 2;
		/// <summary>
		/// The maximum number of entries in a single checkout.
		/// </summary>
		public const int CHECKOUT_MAX_ENTRIES = 10;
		/// <summary>
		/// The most recent version of the <see cref="CopyEntitlementById" /> API.
		/// </summary>
		public const int COPYENTITLEMENTBYID_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="CopyEntitlementByIndex" /> API.
		/// </summary>
		public const int COPYENTITLEMENTBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyEntitlementByNameAndIndex" /> API.
		/// </summary>
		public const int COPYENTITLEMENTBYNAMEANDINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyItemById" /> API.
		/// </summary>
		public const int COPYITEMBYID_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyItemImageInfoByIndex" /> API.
		/// </summary>
		public const int COPYITEMIMAGEINFOBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyItemReleaseByIndex" /> API.
		/// </summary>
		public const int COPYITEMRELEASEBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyLastRedeemedEntitlementByIndex" /> API.
		/// </summary>
		public const int COPYLASTREDEEMEDENTITLEMENTBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyOfferById" /> API.
		/// </summary>
		public const int COPYOFFERBYID_API_LATEST = 3;
		/// <summary>
		/// The most recent version of the <see cref="CopyOfferByIndex" /> API.
		/// </summary>
		public const int COPYOFFERBYINDEX_API_LATEST = 3;
		/// <summary>
		/// The most recent version of the <see cref="CopyOfferImageInfoByIndex" /> API.
		/// </summary>
		public const int COPYOFFERIMAGEINFOBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyOfferItemByIndex" /> API.
		/// </summary>
		public const int COPYOFFERITEMBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyTransactionById" /> Function.
		/// </summary>
		public const int COPYTRANSACTIONBYID_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyTransactionByIndex" /> Function.
		/// </summary>
		public const int COPYTRANSACTIONBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The maximum length of an entitlement ID
		/// </summary>
		public const int ENTITLEMENTID_MAX_LENGTH = 32;
		/// <summary>
		/// The most recent version of the <see cref="Entitlement" /> struct.
		/// </summary>
		public const int ENTITLEMENT_API_LATEST = 2;
		/// <summary>
		/// Timestamp value representing an undefined EndTimestamp for <see cref="Entitlement" />
		/// </summary>
		public const int ENTITLEMENT_ENDTIMESTAMP_UNDEFINED = -1;
		/// <summary>
		/// The most recent version of the <see cref="GetEntitlementsByNameCount" /> API.
		/// </summary>
		public const int GETENTITLEMENTSBYNAMECOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetEntitlementsCount" /> API.
		/// </summary>
		public const int GETENTITLEMENTSCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetItemImageInfoCount" /> API.
		/// </summary>
		public const int GETITEMIMAGEINFOCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetItemReleaseCount" /> API.
		/// </summary>
		public const int GETITEMRELEASECOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetLastRedeemedEntitlementsCount" /> API.
		/// </summary>
		public const int GETLASTREDEEMEDENTITLEMENTSCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetOfferCount" /> API.
		/// </summary>
		public const int GETOFFERCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetOfferImageInfoCount" /> API.
		/// </summary>
		public const int GETOFFERIMAGEINFOCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetOfferItemCount" /> API.
		/// </summary>
		public const int GETOFFERITEMCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetTransactionCount" /> Function.
		/// </summary>
		public const int GETTRANSACTIONCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="ItemOwnership" /> struct.
		/// </summary>
		public const int ITEMOWNERSHIP_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="KeyImageInfo" /> struct.
		/// </summary>
		public const int KEYIMAGEINFO_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="QueryEntitlements" /> API.
		/// </summary>
		public const int QUERYENTITLEMENTS_API_LATEST = 3;
		/// <summary>
		/// The maximum number of entitlements that may be queried in a single QueryEntitlements API call.
		/// </summary>
		public const int QUERYENTITLEMENTS_MAX_ENTITLEMENT_IDS = 256;
		/// <summary>
		/// The most recent version of the <see cref="QueryEntitlementToken" /> API.
		/// </summary>
		public const int QUERYENTITLEMENTTOKEN_API_LATEST = 1;
		/// <summary>
		/// The maximum number of entitlements that may be queried in a single pass.
		/// </summary>
		public const int QUERYENTITLEMENTTOKEN_MAX_ENTITLEMENT_IDS = 32;
		/// <summary>
		/// The most recent version of the <see cref="QueryOffers" /> API.
		/// </summary>
		public const int QUERYOFFERS_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="QueryOwnershipBySandboxIds" /> API.
		/// </summary>
		public const int QUERYOWNERSHIPBYSANDBOXIDSOPTIONS_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="QueryOwnershipToken" /> API.
		/// </summary>
		public const int QUERYOWNERSHIPTOKEN_API_LATEST = 2;
		/// <summary>
		/// The maximum number of catalog items that may be queried in a single pass
		/// </summary>
		public const int QUERYOWNERSHIPTOKEN_MAX_CATALOGITEM_IDS = 32;
		/// <summary>
		/// The most recent version of the <see cref="QueryOwnership" /> API.
		/// </summary>
		public const int QUERYOWNERSHIP_API_LATEST = 2;
		/// <summary>
		/// The maximum number of catalog items that may be queried in a single pass
		/// </summary>
		public const int QUERYOWNERSHIP_MAX_CATALOG_IDS = 400;
		/// <summary>
		/// The maximum number of Sandbox Ids that may be queried in a single pass.
		/// </summary>
		public const int QUERYOWNERSHIP_MAX_SANDBOX_IDS = 10;
		/// <summary>
		/// The most recent version of the <see cref="RedeemEntitlements" /> API.
		/// </summary>
		public const int REDEEMENTITLEMENTS_API_LATEST = 2;
		/// <summary>
		/// The maximum number of entitlement IDs that may be redeemed in a single pass
		/// </summary>
		public const int REDEEMENTITLEMENTS_MAX_IDS = 32;
		/// <summary>
		/// The maximum length of a transaction ID.
		/// </summary>
		public const int TRANSACTIONID_MAXIMUM_LENGTH = 64;
		/// <summary>
		/// The most recent version of the <see cref="Transaction.CopyEntitlementByIndex" /> Function.
		/// </summary>
		public const int TRANSACTION_COPYENTITLEMENTBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="Transaction.GetEntitlementsCount" /> Function.
		/// </summary>
		public const int TRANSACTION_GETENTITLEMENTSCOUNT_API_LATEST = 1;

		/// <summary>
		/// Initiates the purchase flow for a set of offers. The callback is triggered after the purchase flow.
		/// On success, the set of entitlements that were unlocked will be cached.
		/// On success, a Transaction ID will be returned. The Transaction ID can be used to obtain an
		/// <see cref="Transaction" /> handle. The handle can then be used to retrieve the entitlements rewarded by the purchase.
		/// <see cref="Transaction.Release" />
		/// </summary>
		/// <param name="options">
		/// structure containing filter criteria
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void Checkout(ref CheckoutOptions options, object clientData, OnCheckoutCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(CheckoutOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Ecom_Checkout(InnerHandle, ref optionsInternal, clientDataPointer, OnCheckoutCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Fetches the entitlement with the given ID.
		/// <see cref="CopyEntitlementByNameAndIndex" />
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID and entitlement ID being accessed
		/// </param>
		/// <param name="outEntitlement">
		/// the entitlement for the given ID, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutEntitlement
		/// <see cref="Result.EcomEntitlementStale" /> if the entitlement information is stale and passed out in OutEntitlement
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the entitlement is not found
		/// </returns>
		public Result CopyEntitlementById(ref CopyEntitlementByIdOptions options, out Entitlement? outEntitlement)
		{
			var optionsInternal = default(CopyEntitlementByIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outEntitlementPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Ecom_CopyEntitlementById(InnerHandle, ref optionsInternal, out outEntitlementPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<EntitlementInternal, Entitlement>(outEntitlementPointer, out outEntitlement);
			if (outEntitlementPointer != IntPtr.Zero)
			{
				Bindings.EOS_Ecom_Entitlement_Release(outEntitlementPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches an entitlement from a given index.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID and index being accessed
		/// </param>
		/// <param name="outEntitlement">
		/// the entitlement for the given index, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutEntitlement
		/// <see cref="Result.EcomEntitlementStale" /> if the entitlement information is stale and passed out in OutEntitlement
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the entitlement is not found
		/// </returns>
		public Result CopyEntitlementByIndex(ref CopyEntitlementByIndexOptions options, out Entitlement? outEntitlement)
		{
			var optionsInternal = default(CopyEntitlementByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outEntitlementPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Ecom_CopyEntitlementByIndex(InnerHandle, ref optionsInternal, out outEntitlementPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<EntitlementInternal, Entitlement>(outEntitlementPointer, out outEntitlement);
			if (outEntitlementPointer != IntPtr.Zero)
			{
				Bindings.EOS_Ecom_Entitlement_Release(outEntitlementPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches a single entitlement with a given Entitlement Name. The Index is used to access individual
		/// entitlements among those with the same Entitlement Name. The Index can be a value from 0 to
		/// one less than the result from <see cref="GetEntitlementsByNameCount" />.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID, entitlement name, and index being accessed
		/// </param>
		/// <param name="outEntitlement">
		/// the entitlement for the given name index pair, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutEntitlement
		/// <see cref="Result.EcomEntitlementStale" /> if the entitlement information is stale and passed out in OutEntitlement
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the entitlement is not found
		/// </returns>
		public Result CopyEntitlementByNameAndIndex(ref CopyEntitlementByNameAndIndexOptions options, out Entitlement? outEntitlement)
		{
			var optionsInternal = default(CopyEntitlementByNameAndIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outEntitlementPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Ecom_CopyEntitlementByNameAndIndex(InnerHandle, ref optionsInternal, out outEntitlementPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<EntitlementInternal, Entitlement>(outEntitlementPointer, out outEntitlement);
			if (outEntitlementPointer != IntPtr.Zero)
			{
				Bindings.EOS_Ecom_Entitlement_Release(outEntitlementPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches an item with a given ID.
		/// <see cref="Release" />
		/// <see cref="GetItemImageInfoCount" />
		/// <see cref="GetItemReleaseCount" />
		/// </summary>
		/// <param name="options">
		/// structure containing the item ID being accessed
		/// </param>
		/// <param name="outItem">
		/// the item for the given index, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutItem
		/// <see cref="Result.EcomCatalogItemStale" /> if the item information is stale and passed out in OutItem
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the offer is not found
		/// </returns>
		public Result CopyItemById(ref CopyItemByIdOptions options, out CatalogItem? outItem)
		{
			var optionsInternal = default(CopyItemByIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outItemPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Ecom_CopyItemById(InnerHandle, ref optionsInternal, out outItemPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<CatalogItemInternal, CatalogItem>(outItemPointer, out outItem);
			if (outItemPointer != IntPtr.Zero)
			{
				Bindings.EOS_Ecom_CatalogItem_Release(outItemPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches an image from a given index.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// structure containing the item ID and index being accessed
		/// </param>
		/// <param name="outImageInfo">
		/// the image for the given index, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutImageInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.EcomCatalogItemStale" /> if the associated item information is stale
		/// <see cref="Result.NotFound" /> if the image is not found
		/// </returns>
		public Result CopyItemImageInfoByIndex(ref CopyItemImageInfoByIndexOptions options, out KeyImageInfo? outImageInfo)
		{
			var optionsInternal = default(CopyItemImageInfoByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outImageInfoPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Ecom_CopyItemImageInfoByIndex(InnerHandle, ref optionsInternal, out outImageInfoPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<KeyImageInfoInternal, KeyImageInfo>(outImageInfoPointer, out outImageInfo);
			if (outImageInfoPointer != IntPtr.Zero)
			{
				Bindings.EOS_Ecom_KeyImageInfo_Release(outImageInfoPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches a release from a given index.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// structure containing the item ID and index being accessed
		/// </param>
		/// <param name="outRelease">
		/// the release for the given index, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutRelease
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.EcomCatalogItemStale" /> if the associated item information is stale
		/// <see cref="Result.NotFound" /> if the release is not found
		/// </returns>
		public Result CopyItemReleaseByIndex(ref CopyItemReleaseByIndexOptions options, out CatalogRelease? outRelease)
		{
			var optionsInternal = default(CopyItemReleaseByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outReleasePointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Ecom_CopyItemReleaseByIndex(InnerHandle, ref optionsInternal, out outReleasePointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<CatalogReleaseInternal, CatalogRelease>(outReleasePointer, out outRelease);
			if (outReleasePointer != IntPtr.Zero)
			{
				Bindings.EOS_Ecom_CatalogRelease_Release(outReleasePointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches a redeemed entitlement id from a given index.
		/// Only entitlements that were redeemed during the last <see cref="RedeemEntitlements" /> call can be copied.
		/// <see cref="ENTITLEMENTID_MAX_LENGTH" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID and index being accessed
		/// </param>
		/// <param name="outRedeemedEntitlementId">
		/// The ID of the redeemed entitlement. Must be long enough to hold a <see cref="Utf8String" /> of <see cref="ENTITLEMENTID_MAX_LENGTH" />.
		/// </param>
		/// <param name="inOutRedeemedEntitlementIdLength">
		/// The size of the OutRedeemedEntitlementId in characters.
		/// The input buffer should include enough space to be <see langword="null" />-terminated.
		/// When the function returns, this parameter will be filled with the length of the <see cref="Utf8String" /> copied into OutRedeemedEntitlementId.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutRedeemedEntitlementId
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the entitlement id is not found
		/// </returns>
		public Result CopyLastRedeemedEntitlementByIndex(ref CopyLastRedeemedEntitlementByIndexOptions options, out Utf8String outRedeemedEntitlementId)
		{
			var optionsInternal = default(CopyLastRedeemedEntitlementByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			int inOutRedeemedEntitlementIdLength = ENTITLEMENTID_MAX_LENGTH + 1;
			var outRedeemedEntitlementIdPointer = Helper.AddAllocation(inOutRedeemedEntitlementIdLength);

			var callResult = Bindings.EOS_Ecom_CopyLastRedeemedEntitlementByIndex(InnerHandle, ref optionsInternal, outRedeemedEntitlementIdPointer, ref inOutRedeemedEntitlementIdLength);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outRedeemedEntitlementIdPointer, out outRedeemedEntitlementId);
			Helper.Dispose(ref outRedeemedEntitlementIdPointer);

			return callResult;
		}

		/// <summary>
		/// Fetches an offer with a given ID. The pricing and text are localized to the provided account.
		/// <see cref="Release" />
		/// <see cref="GetOfferItemCount" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID and offer ID being accessed
		/// </param>
		/// <param name="outOffer">
		/// the offer for the given index, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutOffer
		/// <see cref="Result.EcomCatalogOfferStale" /> if the offer information is stale and passed out in OutOffer
		/// <see cref="Result.EcomCatalogOfferPriceInvalid" /> if the offer information has an invalid price and passed out in OutOffer
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the offer is not found
		/// </returns>
		public Result CopyOfferById(ref CopyOfferByIdOptions options, out CatalogOffer? outOffer)
		{
			var optionsInternal = default(CopyOfferByIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outOfferPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Ecom_CopyOfferById(InnerHandle, ref optionsInternal, out outOfferPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<CatalogOfferInternal, CatalogOffer>(outOfferPointer, out outOffer);
			if (outOfferPointer != IntPtr.Zero)
			{
				Bindings.EOS_Ecom_CatalogOffer_Release(outOfferPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches an offer from a given index. The pricing and text are localized to the provided account.
		/// <see cref="Release" />
		/// <see cref="GetOfferItemCount" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID and index being accessed
		/// </param>
		/// <param name="outOffer">
		/// the offer for the given index, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutOffer
		/// <see cref="Result.EcomCatalogOfferStale" /> if the offer information is stale and passed out in OutOffer
		/// <see cref="Result.EcomCatalogOfferPriceInvalid" /> if the offer information has an invalid price and passed out in OutOffer
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the offer is not found
		/// </returns>
		public Result CopyOfferByIndex(ref CopyOfferByIndexOptions options, out CatalogOffer? outOffer)
		{
			var optionsInternal = default(CopyOfferByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outOfferPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Ecom_CopyOfferByIndex(InnerHandle, ref optionsInternal, out outOfferPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<CatalogOfferInternal, CatalogOffer>(outOfferPointer, out outOffer);
			if (outOfferPointer != IntPtr.Zero)
			{
				Bindings.EOS_Ecom_CatalogOffer_Release(outOfferPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches an image from a given index.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// structure containing the offer ID and index being accessed
		/// </param>
		/// <param name="outImageInfo">
		/// the image for the given index, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutImageInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.EcomCatalogOfferStale" /> if the associated offer information is stale
		/// <see cref="Result.NotFound" /> if the image is not found
		/// </returns>
		public Result CopyOfferImageInfoByIndex(ref CopyOfferImageInfoByIndexOptions options, out KeyImageInfo? outImageInfo)
		{
			var optionsInternal = default(CopyOfferImageInfoByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outImageInfoPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Ecom_CopyOfferImageInfoByIndex(InnerHandle, ref optionsInternal, out outImageInfoPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<KeyImageInfoInternal, KeyImageInfo>(outImageInfoPointer, out outImageInfo);
			if (outImageInfoPointer != IntPtr.Zero)
			{
				Bindings.EOS_Ecom_KeyImageInfo_Release(outImageInfoPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches an item from a given index.
		/// <see cref="Release" />
		/// <see cref="GetItemImageInfoCount" />
		/// <see cref="GetItemReleaseCount" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID and index being accessed
		/// </param>
		/// <param name="outItem">
		/// the item for the given index, if it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutItem
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.EcomCatalogItemStale" /> if the item information is stale
		/// <see cref="Result.NotFound" /> if the item is not found
		/// </returns>
		public Result CopyOfferItemByIndex(ref CopyOfferItemByIndexOptions options, out CatalogItem? outItem)
		{
			var optionsInternal = default(CopyOfferItemByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outItemPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Ecom_CopyOfferItemByIndex(InnerHandle, ref optionsInternal, out outItemPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<CatalogItemInternal, CatalogItem>(outItemPointer, out outItem);
			if (outItemPointer != IntPtr.Zero)
			{
				Bindings.EOS_Ecom_CatalogItem_Release(outItemPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches the transaction handle at the given index.
		/// <see cref="CheckoutCallbackInfo" />
		/// <see cref="Transaction.Release" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID and transaction ID being accessed
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutTransaction
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the transaction is not found
		/// </returns>
		public Result CopyTransactionById(ref CopyTransactionByIdOptions options, out Transaction outTransaction)
		{
			var optionsInternal = default(CopyTransactionByIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outTransactionInnerHandle = IntPtr.Zero;

			var callResult = Bindings.EOS_Ecom_CopyTransactionById(InnerHandle, ref optionsInternal, out outTransactionInnerHandle);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outTransactionInnerHandle, out outTransaction);

			return callResult;
		}

		/// <summary>
		/// Fetches the transaction handle at the given index.
		/// <see cref="CheckoutCallbackInfo" />
		/// <see cref="Transaction.Release" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID and index being accessed
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutTransaction
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the transaction is not found
		/// </returns>
		public Result CopyTransactionByIndex(ref CopyTransactionByIndexOptions options, out Transaction outTransaction)
		{
			var optionsInternal = default(CopyTransactionByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outTransactionInnerHandle = IntPtr.Zero;

			var callResult = Bindings.EOS_Ecom_CopyTransactionByIndex(InnerHandle, ref optionsInternal, out outTransactionInnerHandle);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outTransactionInnerHandle, out outTransaction);

			return callResult;
		}

		/// <summary>
		/// Fetch the number of entitlements with the given Entitlement Name that are cached for a given local user.
		/// <see cref="CopyEntitlementByNameAndIndex" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID and name being accessed
		/// </param>
		/// <returns>
		/// the number of entitlements found.
		/// </returns>
		public uint GetEntitlementsByNameCount(ref GetEntitlementsByNameCountOptions options)
		{
			var optionsInternal = default(GetEntitlementsByNameCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Ecom_GetEntitlementsByNameCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Fetch the number of entitlements that are cached for a given local user.
		/// <see cref="CopyEntitlementByIndex" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID being accessed
		/// </param>
		/// <returns>
		/// the number of entitlements found.
		/// </returns>
		public uint GetEntitlementsCount(ref GetEntitlementsCountOptions options)
		{
			var optionsInternal = default(GetEntitlementsCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Ecom_GetEntitlementsCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Fetch the number of images that are associated with a given cached item for a local user.
		/// </summary>
		/// <returns>
		/// the number of images found.
		/// </returns>
		public uint GetItemImageInfoCount(ref GetItemImageInfoCountOptions options)
		{
			var optionsInternal = default(GetItemImageInfoCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Ecom_GetItemImageInfoCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Fetch the number of releases that are associated with a given cached item for a local user.
		/// </summary>
		/// <returns>
		/// the number of releases found.
		/// </returns>
		public uint GetItemReleaseCount(ref GetItemReleaseCountOptions options)
		{
			var optionsInternal = default(GetItemReleaseCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Ecom_GetItemReleaseCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Fetch the number of entitlements that were redeemed during the last <see cref="RedeemEntitlements" /> call.
		/// <see cref="CopyLastRedeemedEntitlementByIndex" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID
		/// </param>
		/// <returns>
		/// the number of the redeemed entitlements.
		/// </returns>
		public uint GetLastRedeemedEntitlementsCount(ref GetLastRedeemedEntitlementsCountOptions options)
		{
			var optionsInternal = default(GetLastRedeemedEntitlementsCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Ecom_GetLastRedeemedEntitlementsCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Fetch the number of offers that are cached for a given local user.
		/// <see cref="CopyOfferByIndex" />
		/// </summary>
		/// <param name="options">
		/// structure containing the Epic Account ID being accessed
		/// </param>
		/// <returns>
		/// the number of offers found.
		/// </returns>
		public uint GetOfferCount(ref GetOfferCountOptions options)
		{
			var optionsInternal = default(GetOfferCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Ecom_GetOfferCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Fetch the number of images that are associated with a given cached offer for a local user.
		/// </summary>
		/// <returns>
		/// the number of images found.
		/// </returns>
		public uint GetOfferImageInfoCount(ref GetOfferImageInfoCountOptions options)
		{
			var optionsInternal = default(GetOfferImageInfoCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Ecom_GetOfferImageInfoCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Fetch the number of items that are associated with a given cached offer for a local user.
		/// </summary>
		/// <returns>
		/// the number of items found.
		/// </returns>
		public uint GetOfferItemCount(ref GetOfferItemCountOptions options)
		{
			var optionsInternal = default(GetOfferItemCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Ecom_GetOfferItemCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Fetch the number of transactions that are cached for a given local user.
		/// <see cref="CheckoutCallbackInfo" />
		/// <see cref="CopyTransactionByIndex" />
		/// </summary>
		/// <returns>
		/// the number of transactions found.
		/// </returns>
		public uint GetTransactionCount(ref GetTransactionCountOptions options)
		{
			var optionsInternal = default(GetTransactionCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Ecom_GetTransactionCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Query the entitlement verification status defined with Epic Online Services.
		/// An optional set of entitlement names can be provided to filter the set of entitlements associated with the account.
		/// The data is return via the callback in the form of a signed JWT that should be verified by an external backend server using a public key for authenticity.
		/// </summary>
		/// <param name="options">
		/// structure containing the account and catalog item IDs to retrieve in token form
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void QueryEntitlementToken(ref QueryEntitlementTokenOptions options, object clientData, OnQueryEntitlementTokenCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryEntitlementTokenOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Ecom_QueryEntitlementToken(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryEntitlementTokenCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Query the entitlement information defined with Epic Online Services.
		/// A set of entitlement names can be provided to filter the set of entitlements associated with the account.
		/// This data will be cached for a limited time and retrieved again from the backend when necessary.
		/// Depending on the number of entitlements passed, the SDK splits the query into smaller batch requests to the backend and aggregates the result.
		/// Note: If one of the request batches fails, no data is cached and the entire query is marked as failed.
		/// Use <see cref="CopyEntitlementByIndex" />, <see cref="CopyEntitlementByNameAndIndex" />, and <see cref="CopyEntitlementById" /> to get the entitlement details.
		/// Use <see cref="GetEntitlementsByNameCount" /> to retrieve the number of entitlements with a specific entitlement name.
		/// Note: If a durable item is queried used the QueryEntitlements API, the callback returns with a <see cref="Result.InvalidRequest" /> result code. Durable item ownership should be queried using the <see cref="QueryOwnership" /> API.
		/// </summary>
		/// <param name="options">
		/// structure containing the account and entitlement names to retrieve
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void QueryEntitlements(ref QueryEntitlementsOptions options, object clientData, OnQueryEntitlementsCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryEntitlementsOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Ecom_QueryEntitlements(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryEntitlementsCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Query for a list of catalog offers defined with Epic Online Services.
		/// This data will be cached for a limited time and retrieved again from the backend when necessary.
		/// </summary>
		/// <param name="options">
		/// structure containing filter criteria
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void QueryOffers(ref QueryOffersOptions options, object clientData, OnQueryOffersCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryOffersOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Ecom_QueryOffers(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryOffersCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Query the ownership status for a given list of catalog item IDs defined with Epic Online Services.
		/// This data will be cached for a limited time and retrieved again from the backend when necessary
		/// Depending on the number of catalog item ids passed, the SDK splits the query into smaller batch requests to the backend and aggregates the result.
		/// Note: If one of the request batches fails, no data is cached and the entire query is marked as failed.
		/// </summary>
		/// <param name="options">
		/// structure containing the account and catalog item IDs to retrieve
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void QueryOwnership(ref QueryOwnershipOptions options, object clientData, OnQueryOwnershipCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryOwnershipOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Ecom_QueryOwnership(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryOwnershipCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Query the ownership status of all catalog item IDs under the given list of Sandbox IDs defined with Epic Online Services.
		/// This data will be cached for a limited time and retrieved again from the backend when necessary.
		/// </summary>
		/// <param name="options">
		/// structure containing the account and Sandbox IDs to retrieve.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error.
		/// </param>
		public void QueryOwnershipBySandboxIds(ref QueryOwnershipBySandboxIdsOptions options, object clientData, OnQueryOwnershipBySandboxIdsCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryOwnershipBySandboxIdsOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Ecom_QueryOwnershipBySandboxIds(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryOwnershipBySandboxIdsCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Query the ownership status for a given list of catalog item IDs defined with Epic Online Services.
		/// The data is return via the callback in the form of a signed JWT that should be verified by an external backend server using a public key for authenticity.
		/// </summary>
		/// <param name="options">
		/// structure containing the account and catalog item IDs to retrieve in token form
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void QueryOwnershipToken(ref QueryOwnershipTokenOptions options, object clientData, OnQueryOwnershipTokenCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryOwnershipTokenOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Ecom_QueryOwnershipToken(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryOwnershipTokenCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Requests that the provided entitlement be marked redeemed. This will cause that entitlement
		/// to no longer be returned from QueryEntitlements unless the include redeemed request flag is set <see langword="true" />.
		/// </summary>
		/// <param name="options">
		/// structure containing entitlement to redeem
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void RedeemEntitlements(ref RedeemEntitlementsOptions options, object clientData, OnRedeemEntitlementsCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(RedeemEntitlementsOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Ecom_RedeemEntitlements(InnerHandle, ref optionsInternal, clientDataPointer, OnRedeemEntitlementsCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}
	}
}

// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.P2P
{
	public sealed partial class P2PInterface : Handle
	{
		public P2PInterface()
		{
		}

		public P2PInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="AcceptConnection" /> API.
		/// </summary>
		public const int ACCEPTCONNECTION_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyIncomingPacketQueueFull" /> API.
		/// </summary>
		public const int ADDNOTIFYINCOMINGPACKETQUEUEFULL_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyPeerConnectionClosed" /> API.
		/// </summary>
		public const int ADDNOTIFYPEERCONNECTIONCLOSED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyPeerConnectionEstablished" /> API.
		/// </summary>
		public const int ADDNOTIFYPEERCONNECTIONESTABLISHED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyPeerConnectionInterrupted" /> API.
		/// </summary>
		public const int ADDNOTIFYPEERCONNECTIONINTERRUPTED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyPeerConnectionRequest" /> API.
		/// </summary>
		public const int ADDNOTIFYPEERCONNECTIONREQUEST_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="ClearPacketQueue" /> API.
		/// </summary>
		public const int CLEARPACKETQUEUE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CloseConnections" /> API.
		/// </summary>
		public const int CLOSECONNECTIONS_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CloseConnection" /> API.
		/// </summary>
		public const int CLOSECONNECTION_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetNATType" /> API.
		/// </summary>
		public const int GETNATTYPE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetNextReceivedPacketSize" /> API.
		/// </summary>
		public const int GETNEXTRECEIVEDPACKETSIZE_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="GetPacketQueueInfo" /> API.
		/// </summary>
		public const int GETPACKETQUEUEINFO_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetPortRange" /> API.
		/// </summary>
		public const int GETPORTRANGE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetRelayControl" /> API.
		/// </summary>
		public const int GETRELAYCONTROL_API_LATEST = 1;
		/// <summary>
		/// The maximum amount of unique Socket ID connections that can be opened with each remote user. As this limit is only per remote user, you may have more
		/// than this number of Socket IDs across multiple remote users.
		/// </summary>
		public const int MAX_CONNECTIONS = 32;
		/// <summary>
		/// A packet's maximum size in bytes
		/// </summary>
		public const int MAX_PACKET_SIZE = 1170;
		/// <summary>
		/// Helper constant to signify that the packet queue is allowed to grow indefinitely
		/// </summary>
		public const int MAX_QUEUE_SIZE_UNLIMITED = 0;
		/// <summary>
		/// The most recent version of the <see cref="QueryNATType" /> API.
		/// </summary>
		public const int QUERYNATTYPE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="ReceivePacket" /> API.
		/// </summary>
		public const int RECEIVEPACKET_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="SendPacket" /> API.
		/// </summary>
		public const int SENDPACKET_API_LATEST = 3;
		/// <summary>
		/// The most recent version of the <see cref="SetPacketQueueSize" /> API.
		/// </summary>
		public const int SETPACKETQUEUESIZE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SetPortRange" /> API.
		/// </summary>
		public const int SETPORTRANGE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SetRelayControl" /> API.
		/// </summary>
		public const int SETRELAYCONTROL_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SocketId" /> structure.
		/// </summary>
		public const int SOCKETID_API_LATEST = 1;
		/// <summary>
		/// The total buffer size of a <see cref="SocketId" /> SocketName, including space for the <see langword="null" />-terminator
		/// </summary>
		public const int SOCKETID_SOCKETNAME_SIZE = 33;

		/// <summary>
		/// Accept or Request a connection with a specific peer on a specific Socket ID.
		/// 
		/// If this connection was not already locally accepted, we will securely message the peer, and trigger a PeerConnectionRequest notification notifying
		/// them of the connection request. If the PeerConnectionRequest notification is not bound for all Socket IDs or for the requested Socket ID in particular,
		/// the request will be silently ignored.
		/// 
		/// If the remote peer accepts the connection, a notification will be broadcast to the <see cref="AddNotifyPeerConnectionEstablished" /> when the connection is
		/// ready to send packets.
		/// 
		/// If multiple Socket IDs are accepted with one peer, they will share one physical socket.
		/// 
		/// Even if a connection is already locally accepted, <see cref="Result.Success" /> will still be returned if the input was valid.
		/// </summary>
		/// <param name="options">
		/// Information about who would like to accept a connection, and which connection
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - if the provided data is valid
		/// <see cref="Result.InvalidParameters" /> - if the provided data is invalid
		/// </returns>
		public Result AcceptConnection(ref AcceptConnectionOptions options)
		{
			var optionsInternal = default(AcceptConnectionOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_P2P_AcceptConnection(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Listen for when our packet queue has become full. This event gives an opportunity to read packets to make
		/// room for new incoming packets. If this event fires and no packets are read by calling <see cref="ReceivePacket" />
		/// or the packet queue size is not increased by <see cref="SetPacketQueueSize" />, any packets that are received after
		/// this event are discarded until there is room again in the queue.
		/// </summary>
		/// <param name="options">
		/// Information about what version of the <see cref="AddNotifyIncomingPacketQueueFull" /> API is supported
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="incomingPacketQueueFullHandler">
		/// The callback to be fired when the incoming packet queue is full
		/// </param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.INVALID_NOTIFICATIONID" /> otherwise
		/// </returns>
		public ulong AddNotifyIncomingPacketQueueFull(ref AddNotifyIncomingPacketQueueFullOptions options, object clientData, OnIncomingPacketQueueFullCallback incomingPacketQueueFullHandler)
		{
			if (incomingPacketQueueFullHandler == null)
			{
				throw new ArgumentNullException("incomingPacketQueueFullHandler");
			}

			var optionsInternal = default(AddNotifyIncomingPacketQueueFullOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, incomingPacketQueueFullHandler);

			var callResult = Bindings.EOS_P2P_AddNotifyIncomingPacketQueueFull(InnerHandle, ref optionsInternal, clientDataPointer, OnIncomingPacketQueueFullCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Listen for when a previously accepted connection that was either open or pending is closed.
		/// When a connection closes, packets are flushed. This includes reliable packets.
		/// <see cref="AddNotifyPeerConnectionEstablished" />
		/// <see cref="AddNotifyPeerConnectionInterrupted" />
		/// <see cref="RemoveNotifyPeerConnectionClosed" />
		/// </summary>
		/// <param name="options">
		/// Information about who would like notifications about closed connections, and for which socket
		/// </param>
		/// <param name="clientData">
		/// This value is returned to the caller when ConnectionClosedHandler is invoked
		/// </param>
		/// <param name="connectionClosedHandler">
		/// The callback to be fired when an open connection has been closed
		/// </param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.INVALID_NOTIFICATIONID" /> otherwise
		/// </returns>
		public ulong AddNotifyPeerConnectionClosed(ref AddNotifyPeerConnectionClosedOptions options, object clientData, OnRemoteConnectionClosedCallback connectionClosedHandler)
		{
			if (connectionClosedHandler == null)
			{
				throw new ArgumentNullException("connectionClosedHandler");
			}

			var optionsInternal = default(AddNotifyPeerConnectionClosedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, connectionClosedHandler);

			var callResult = Bindings.EOS_P2P_AddNotifyPeerConnectionClosed(InnerHandle, ref optionsInternal, clientDataPointer, OnRemoteConnectionClosedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Listen for when a connection is established. This is fired when we first connect to a peer, when we reconnect to a peer after a connection interruption,
		/// and when our underlying network connection type changes (for example, from a direct connection to relay, or vice versa). Network Connection Type changes
		/// will always be broadcast with a <see cref="ConnectionEstablishedType.Reconnection" /> connection type, even if the connection was not interrupted.
		/// If the network status changes from offline or disabled to online, you must call this function again.
		/// <see cref="AddNotifyPeerConnectionInterrupted" />
		/// <see cref="AddNotifyPeerConnectionClosed" />
		/// <see cref="RemoveNotifyPeerConnectionEstablished" />
		/// </summary>
		/// <param name="options">
		/// Information about who would like notifications about established connections, and for which socket
		/// </param>
		/// <param name="clientData">
		/// This value is returned to the caller when ConnectionEstablishedHandler is invoked
		/// </param>
		/// <param name="connectionEstablishedHandler">
		/// The callback to be fired when a connection has been established
		/// </param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.INVALID_NOTIFICATIONID" /> otherwise
		/// </returns>
		public ulong AddNotifyPeerConnectionEstablished(ref AddNotifyPeerConnectionEstablishedOptions options, object clientData, OnPeerConnectionEstablishedCallback connectionEstablishedHandler)
		{
			if (connectionEstablishedHandler == null)
			{
				throw new ArgumentNullException("connectionEstablishedHandler");
			}

			var optionsInternal = default(AddNotifyPeerConnectionEstablishedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, connectionEstablishedHandler);

			var callResult = Bindings.EOS_P2P_AddNotifyPeerConnectionEstablished(InnerHandle, ref optionsInternal, clientDataPointer, OnPeerConnectionEstablishedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Listen for when a previously opened connection is interrupted. The connection will automatically attempt to reestablish, but it may not be successful.
		/// 
		/// If a connection reconnects, it will trigger the P2P PeerConnectionEstablished notification with the <see cref="ConnectionEstablishedType.Reconnection" /> connection type.
		/// If a connection fails to reconnect, it will trigger the P2P PeerConnectionClosed notification.
		/// Packets remain queued during connection interruptions. When a connection closes, packets are flushed. This includes reliable packets.
		/// <see cref="AddNotifyPeerConnectionEstablished" />
		/// <see cref="AddNotifyPeerConnectionClosed" />
		/// <see cref="RemoveNotifyPeerConnectionInterrupted" />
		/// </summary>
		/// <param name="options">
		/// Information about who would like notifications about interrupted connections, and for which socket
		/// </param>
		/// <param name="clientData">
		/// This value is returned to the caller when ConnectionInterruptedHandler is invoked
		/// </param>
		/// <param name="connectionInterruptedHandler">
		/// The callback to be fired when an open connection has been interrupted
		/// </param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.INVALID_NOTIFICATIONID" /> otherwise
		/// </returns>
		public ulong AddNotifyPeerConnectionInterrupted(ref AddNotifyPeerConnectionInterruptedOptions options, object clientData, OnPeerConnectionInterruptedCallback connectionInterruptedHandler)
		{
			if (connectionInterruptedHandler == null)
			{
				throw new ArgumentNullException("connectionInterruptedHandler");
			}

			var optionsInternal = default(AddNotifyPeerConnectionInterruptedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, connectionInterruptedHandler);

			var callResult = Bindings.EOS_P2P_AddNotifyPeerConnectionInterrupted(InnerHandle, ref optionsInternal, clientDataPointer, OnPeerConnectionInterruptedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Listen for incoming connection requests on a particular Socket ID, or optionally all Socket IDs. The bound function
		/// will only be called if the connection has not already been accepted.
		/// If the network status changes from offline or disabled to online, you must call this function again.
		/// <see cref="RemoveNotifyPeerConnectionRequest" />
		/// </summary>
		/// <param name="options">
		/// Information about who would like notifications, and (optionally) only for a specific socket
		/// </param>
		/// <param name="clientData">
		/// This value is returned to the caller when ConnectionRequestHandler is invoked
		/// </param>
		/// <param name="connectionRequestHandler">
		/// The callback to be fired when we receive a connection request
		/// </param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.INVALID_NOTIFICATIONID" /> otherwise
		/// </returns>
		public ulong AddNotifyPeerConnectionRequest(ref AddNotifyPeerConnectionRequestOptions options, object clientData, OnIncomingConnectionRequestCallback connectionRequestHandler)
		{
			if (connectionRequestHandler == null)
			{
				throw new ArgumentNullException("connectionRequestHandler");
			}

			var optionsInternal = default(AddNotifyPeerConnectionRequestOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, connectionRequestHandler);

			var callResult = Bindings.EOS_P2P_AddNotifyPeerConnectionRequest(InnerHandle, ref optionsInternal, clientDataPointer, OnIncomingConnectionRequestCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Clear queued incoming and outgoing packets.
		/// </summary>
		/// <param name="options">
		/// Information about which queues should be cleared
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - if the input options were valid (even if queues were empty and no packets where cleared)
		/// <see cref="Result.IncompatibleVersion" /> - if wrong API version
		/// <see cref="Result.InvalidUser" /> - if an invalid/remote user was used
		/// <see cref="Result.InvalidParameters" /> - if input was invalid in other way
		/// </returns>
		public Result ClearPacketQueue(ref ClearPacketQueueOptions options)
		{
			var optionsInternal = default(ClearPacketQueueOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_P2P_ClearPacketQueue(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// For all (or optionally one specific) Socket ID(s) with a specific peer: stop receiving packets, drop any locally queued packets, and if no other
		/// Socket ID is using the connection with the peer, close the underlying connection.
		/// 
		/// If your application wants to migrate an existing connection with a peer it already connected to, it is recommended to call <see cref="AcceptConnection" />
		/// with the new Socket ID first before calling <see cref="CloseConnection" />, to prevent the shared physical socket from being torn down prematurely.
		/// </summary>
		/// <param name="options">
		/// Information about who would like to close a connection, and which connection.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - if the provided data is valid
		/// <see cref="Result.InvalidParameters" /> - if the provided data is invalid
		/// </returns>
		public Result CloseConnection(ref CloseConnectionOptions options)
		{
			var optionsInternal = default(CloseConnectionOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_P2P_CloseConnection(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Close any open Connections for a specific Peer Connection ID.
		/// </summary>
		/// <param name="options">
		/// Information about who would like to close connections, and by what socket ID
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - if the provided data is valid
		/// <see cref="Result.InvalidParameters" /> - if the provided data is invalid
		/// </returns>
		public Result CloseConnections(ref CloseConnectionsOptions options)
		{
			var optionsInternal = default(CloseConnectionsOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_P2P_CloseConnections(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Get our last-queried NAT-type, if it has been successfully queried.
		/// </summary>
		/// <param name="options">
		/// Information about what version of the <see cref="GetNATType" /> API is supported
		/// </param>
		/// <param name="outNATType">
		/// The queried NAT Type, or unknown if unknown
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - if we have cached data
		/// <see cref="Result.NotFound" /> - If we do not have queried data cached
		/// </returns>
		public Result GetNATType(ref GetNATTypeOptions options, out NATType outNATType)
		{
			var optionsInternal = default(GetNATTypeOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_P2P_GetNATType(InnerHandle, ref optionsInternal, out outNATType);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Gets the size of the packet that will be returned by ReceivePacket for a particular user, if there is any available
		/// packets to be retrieved.
		/// </summary>
		/// <param name="options">
		/// Information about who is requesting the size of their next packet
		/// </param>
		/// <param name="outPacketSizeBytes">
		/// The amount of bytes required to store the data of the next packet for the requested user
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If OutPacketSizeBytes was successfully set and there is data to be received
		/// <see cref="Result.InvalidParameters" /> - If input was invalid
		/// <see cref="Result.NotFound" /> - If there are no packets available for the requesting user
		/// </returns>
		public Result GetNextReceivedPacketSize(ref GetNextReceivedPacketSizeOptions options, out uint outPacketSizeBytes)
		{
			var optionsInternal = default(GetNextReceivedPacketSizeOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_P2P_GetNextReceivedPacketSize(InnerHandle, ref optionsInternal, out outPacketSizeBytes);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Gets the current cached information related to the incoming and outgoing packet queues.
		/// </summary>
		/// <param name="options">
		/// Information about what version of the <see cref="GetPacketQueueInfo" /> API is supported
		/// </param>
		/// <param name="outPacketQueueInfo">
		/// The current information of the incoming and outgoing packet queues
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - if the input options were valid
		/// <see cref="Result.InvalidParameters" /> - if the input was invalid in some way
		/// </returns>
		public Result GetPacketQueueInfo(ref GetPacketQueueInfoOptions options, out PacketQueueInfo outPacketQueueInfo)
		{
			var optionsInternal = default(GetPacketQueueInfoOptionsInternal);
			optionsInternal.Set(ref options);

			var outPacketQueueInfoInternal = default(PacketQueueInfoInternal);

			var callResult = Bindings.EOS_P2P_GetPacketQueueInfo(InnerHandle, ref optionsInternal, out outPacketQueueInfoInternal);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(ref outPacketQueueInfoInternal, out outPacketQueueInfo);

			return callResult;
		}

		/// <summary>
		/// Get the current chosen port and the amount of other ports to try above the chosen port if the chosen port is unavailable.
		/// </summary>
		/// <param name="options">
		/// Information about what version of the <see cref="GetPortRange" /> API is supported
		/// </param>
		/// <param name="outPort">
		/// The port that will be tried first
		/// </param>
		/// <param name="outNumAdditionalPortsToTry">
		/// The amount of ports to try above the value in OutPort, if OutPort is unavailable
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - if the input options were valid
		/// <see cref="Result.InvalidParameters" /> - if the input was invalid in some way
		/// </returns>
		public Result GetPortRange(ref GetPortRangeOptions options, out ushort outPort, out ushort outNumAdditionalPortsToTry)
		{
			var optionsInternal = default(GetPortRangeOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_P2P_GetPortRange(InnerHandle, ref optionsInternal, out outPort, out outNumAdditionalPortsToTry);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Get the current relay control setting.
		/// </summary>
		/// <param name="options">
		/// Information about what version of the <see cref="GetRelayControl" /> API is supported
		/// </param>
		/// <param name="outRelayControl">
		/// The relay control setting currently configured
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - if the input was valid
		/// <see cref="Result.InvalidParameters" /> - if the input was invalid in some way
		/// </returns>
		public Result GetRelayControl(ref GetRelayControlOptions options, out RelayControl outRelayControl)
		{
			var optionsInternal = default(GetRelayControlOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_P2P_GetRelayControl(InnerHandle, ref optionsInternal, out outRelayControl);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Query the current NAT-type of our connection.
		/// </summary>
		/// <param name="options">
		/// Information about what version of the <see cref="QueryNATType" /> API is supported
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// The callback to be fired when we finish querying our NAT type
		/// </param>
		public void QueryNATType(ref QueryNATTypeOptions options, object clientData, OnQueryNATTypeCompleteCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryNATTypeOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_P2P_QueryNATType(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryNATTypeCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Stop listening for full incoming packet queue events on a previously bound handler.
		/// </summary>
		/// <param name="notificationId">
		/// The previously bound notification ID
		/// </param>
		public void RemoveNotifyIncomingPacketQueueFull(ulong notificationId)
		{
			Bindings.EOS_P2P_RemoveNotifyIncomingPacketQueueFull(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Stop notifications for connections being closed on a previously bound handler.
		/// <see cref="AddNotifyPeerConnectionClosed" />
		/// </summary>
		/// <param name="notificationId">
		/// The previously bound notification ID
		/// </param>
		public void RemoveNotifyPeerConnectionClosed(ulong notificationId)
		{
			Bindings.EOS_P2P_RemoveNotifyPeerConnectionClosed(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Stop notifications for connections being established on a previously bound handler.
		/// <see cref="AddNotifyPeerConnectionEstablished" />
		/// </summary>
		/// <param name="notificationId">
		/// The previously bound notification ID
		/// </param>
		public void RemoveNotifyPeerConnectionEstablished(ulong notificationId)
		{
			Bindings.EOS_P2P_RemoveNotifyPeerConnectionEstablished(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Stop notifications for connections being interrupted on a previously bound handler.
		/// <see cref="AddNotifyPeerConnectionInterrupted" />
		/// </summary>
		/// <param name="notificationId">
		/// The previously bound notification ID
		/// </param>
		public void RemoveNotifyPeerConnectionInterrupted(ulong notificationId)
		{
			Bindings.EOS_P2P_RemoveNotifyPeerConnectionInterrupted(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Stop listening for connection requests on a previously bound handler.
		/// <see cref="AddNotifyPeerConnectionRequest" />
		/// </summary>
		/// <param name="notificationId">
		/// The previously bound notification ID
		/// </param>
		public void RemoveNotifyPeerConnectionRequest(ulong notificationId)
		{
			Bindings.EOS_P2P_RemoveNotifyPeerConnectionRequest(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Send a packet to a peer at the specified address. If there is already an open connection to this peer, it will be
		/// sent immediately. If there is no open connection, an attempt to connect to the peer will be made. An <see cref="Result.Success" />
		/// result only means the data was accepted to be sent, not that it has been successfully delivered to the peer.
		/// </summary>
		/// <param name="options">
		/// Information about the data being sent, by who, to who
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If packet was queued to be sent successfully
		/// <see cref="Result.InvalidParameters" /> - If input was invalid
		/// <see cref="Result.LimitExceeded" /> - If amount of data being sent is too large, or the outgoing packet queue was full
		/// <see cref="Result.NoConnection" /> - If bDisableAutoAcceptConnection was set to <see langword="true" /> and the connection was not currently accepted (call <see cref="AcceptConnection" /> first, or set bDisableAutoAcceptConnection to <see langword="false" />)
		/// </returns>
		public Result SendPacket(ref SendPacketOptions options)
		{
			var optionsInternal = default(SendPacketOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_P2P_SendPacket(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Sets the maximum packet queue sizes that packets waiting to be sent or received can use. If the packet queue
		/// size is made smaller than the current queue size while there are packets in the queue that would push this
		/// packet size over, existing packets are kept but new packets may not be added to the full queue until enough
		/// packets are sent or received.
		/// </summary>
		/// <param name="options">
		/// Information about packet queue size
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - if the input options were valid
		/// <see cref="Result.InvalidParameters" /> - if the input was invalid in some way
		/// </returns>
		public Result SetPacketQueueSize(ref SetPacketQueueSizeOptions options)
		{
			var optionsInternal = default(SetPacketQueueSizeOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_P2P_SetPacketQueueSize(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Set configuration options related to network ports.
		/// </summary>
		/// <param name="options">
		/// Information about network ports config options
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - if the options were set successfully
		/// <see cref="Result.InvalidParameters" /> - if the options are invalid in some way
		/// </returns>
		public Result SetPortRange(ref SetPortRangeOptions options)
		{
			var optionsInternal = default(SetPortRangeOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_P2P_SetPortRange(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Set how relay servers are to be used. This setting does not immediately apply to existing connections, but may apply to existing
		/// connections if the connection requires renegotiation.
		/// <see cref="RelayControl" />
		/// </summary>
		/// <param name="options">
		/// Information about relay server config options
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - if the options were set successfully
		/// <see cref="Result.InvalidParameters" /> - if the options are invalid in some way
		/// </returns>
		public Result SetRelayControl(ref SetRelayControlOptions options)
		{
			var optionsInternal = default(SetRelayControlOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_P2P_SetRelayControl(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}
	}
}

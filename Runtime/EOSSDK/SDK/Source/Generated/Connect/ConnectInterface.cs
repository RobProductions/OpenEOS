// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.Connect
{
	public sealed partial class ConnectInterface : Handle
	{
		public ConnectInterface()
		{
		}

		public ConnectInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyAuthExpiration" /> API.
		/// </summary>
		public const int ADDNOTIFYAUTHEXPIRATION_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLoginStatusChanged" /> API.
		/// </summary>
		public const int ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyIdToken" /> API.
		/// </summary>
		public const int COPYIDTOKEN_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyProductUserExternalAccountByAccountId" /> API.
		/// </summary>
		public const int COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTID_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyProductUserExternalAccountByAccountType" /> API.
		/// </summary>
		public const int COPYPRODUCTUSEREXTERNALACCOUNTBYACCOUNTTYPE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyProductUserExternalAccountByIndex" /> API.
		/// </summary>
		public const int COPYPRODUCTUSEREXTERNALACCOUNTBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyProductUserInfo" /> API.
		/// </summary>
		public const int COPYPRODUCTUSERINFO_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CreateDeviceId" /> API.
		/// </summary>
		public const int CREATEDEVICEID_API_LATEST = 1;
		/// <summary>
		/// Max length of a device model name, not including the terminating <see langword="null" />
		/// </summary>
		public const int CREATEDEVICEID_DEVICEMODEL_MAX_LENGTH = 64;
		/// <summary>
		/// The most recent version of the <see cref="CreateUser" /> API.
		/// </summary>
		public const int CREATEUSER_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="Credentials" /> struct.
		/// </summary>
		public const int CREDENTIALS_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="DeleteDeviceId" /> API.
		/// </summary>
		public const int DELETEDEVICEID_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="ExternalAccountInfo" /> struct.
		/// </summary>
		public const int EXTERNALACCOUNTINFO_API_LATEST = 1;
		/// <summary>
		/// Max length of an external account ID in <see cref="Utf8String" /> form
		/// </summary>
		public const int EXTERNAL_ACCOUNT_ID_MAX_LENGTH = 256;
		/// <summary>
		/// DEPRECATED! Use <see cref="GETEXTERNALACCOUNTMAPPING_API_LATEST" /> instead.
		/// </summary>
		public const int GETEXTERNALACCOUNTMAPPINGS_API_LATEST = GETEXTERNALACCOUNTMAPPING_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="GetExternalAccountMapping" /> API.
		/// </summary>
		public const int GETEXTERNALACCOUNTMAPPING_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetProductUserExternalAccountCount" /> API.
		/// </summary>
		public const int GETPRODUCTUSEREXTERNALACCOUNTCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetProductUserIdMapping" /> API.
		/// </summary>
		public const int GETPRODUCTUSERIDMAPPING_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="IdToken" /> struct.
		/// </summary>
		public const int IDTOKEN_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="LinkAccount" /> API.
		/// </summary>
		public const int LINKACCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="Login" /> API.
		/// </summary>
		public const int LOGIN_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="Logout" /> API.
		/// </summary>
		public const int LOGOUT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="OnAuthExpirationCallback" /> API.
		/// </summary>
		public const int ONAUTHEXPIRATIONCALLBACK_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="QueryExternalAccountMappings" /> API.
		/// </summary>
		public const int QUERYEXTERNALACCOUNTMAPPINGS_API_LATEST = 1;
		/// <summary>
		/// Maximum number of account IDs that can be queried at once
		/// </summary>
		public const int QUERYEXTERNALACCOUNTMAPPINGS_MAX_ACCOUNT_IDS = 128;
		/// <summary>
		/// The most recent version of the <see cref="QueryProductUserIdMappings" /> API.
		/// </summary>
		public const int QUERYPRODUCTUSERIDMAPPINGS_API_LATEST = 2;
		/// <summary>
		/// Timestamp value representing an undefined time for last login time.
		/// </summary>
		public const int TIME_UNDEFINED = -1;
		/// <summary>
		/// The most recent version of the <see cref="TransferDeviceIdAccount" /> API.
		/// </summary>
		public const int TRANSFERDEVICEIDACCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="UnlinkAccount" /> API.
		/// </summary>
		public const int UNLINKACCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="UserLoginInfo" /> struct.
		/// </summary>
		public const int USERLOGININFO_API_LATEST = 2;
		/// <summary>
		/// Max length of a display name, not including the terminating <see langword="null" />.
		/// </summary>
		public const int USERLOGININFO_DISPLAYNAME_MAX_LENGTH = 32;
		/// <summary>
		/// The most recent version of the <see cref="VerifyIdToken" /> API.
		/// </summary>
		public const int VERIFYIDTOKEN_API_LATEST = 1;

		/// <summary>
		/// Register to receive upcoming authentication expiration notifications.
		/// Notification is approximately 10 minutes prior to expiration.
		/// Call <see cref="Login" /> again with valid third party credentials to refresh access.
		/// If the returned NotificationId is valid, you must call <see cref="RemoveNotifyAuthExpiration" /> when you no longer wish to have your NotificationHandler called.
		/// </summary>
		/// <param name="options">
		/// structure containing the API version of the callback to use.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the callback.
		/// </param>
		/// <param name="notification">
		/// a callback that is fired when the authentication is about to expire.
		/// </param>
		/// <returns>
		/// handle representing the registered callback.
		/// </returns>
		public ulong AddNotifyAuthExpiration(ref AddNotifyAuthExpirationOptions options, object clientData, OnAuthExpirationCallback notification)
		{
			if (notification == null)
			{
				throw new ArgumentNullException("notification");
			}

			var optionsInternal = default(AddNotifyAuthExpirationOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notification);

			var callResult = Bindings.EOS_Connect_AddNotifyAuthExpiration(InnerHandle, ref optionsInternal, clientDataPointer, OnAuthExpirationCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Register to receive user login status updates.
		/// If the returned NotificationId is valid, you must call <see cref="RemoveNotifyLoginStatusChanged" /> when you no longer wish to have your NotificationHandler called.
		/// </summary>
		/// <param name="options">
		/// structure containing the API version of the callback to use.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the callback.
		/// </param>
		/// <param name="notification">
		/// a callback that is fired when the login status for a user changes.
		/// </param>
		/// <returns>
		/// handle representing the registered callback.
		/// </returns>
		public ulong AddNotifyLoginStatusChanged(ref AddNotifyLoginStatusChangedOptions options, object clientData, OnLoginStatusChangedCallback notification)
		{
			if (notification == null)
			{
				throw new ArgumentNullException("notification");
			}

			var optionsInternal = default(AddNotifyLoginStatusChangedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notification);

			var callResult = Bindings.EOS_Connect_AddNotifyLoginStatusChanged(InnerHandle, ref optionsInternal, clientDataPointer, OnLoginStatusChangedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Fetches an ID token for a Product User ID.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the ID token to copy.
		/// </param>
		/// <param name="outIdToken">
		/// The ID token for the given user, if it exists and is valid; use <see cref="Release" /> when finished.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutIdToken.
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter.
		/// <see cref="Result.NotFound" /> if the ID token is not found or expired.
		/// </returns>
		public Result CopyIdToken(ref CopyIdTokenOptions options, out IdToken? outIdToken)
		{
			var optionsInternal = default(CopyIdTokenOptionsInternal);
			optionsInternal.Set(ref options);

			var outIdTokenPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Connect_CopyIdToken(InnerHandle, ref optionsInternal, out outIdTokenPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<IdTokenInternal, IdToken>(outIdTokenPointer, out outIdToken);
			if (outIdTokenPointer != IntPtr.Zero)
			{
				Bindings.EOS_Connect_IdToken_Release(outIdTokenPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetch information about an external account linked to a Product User ID.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the target external account ID.
		/// </param>
		/// <param name="outExternalAccountInfo">
		/// The external account info data for the user with given external account ID.
		/// </param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo.
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo.
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter.
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet.
		/// </returns>
		public Result CopyProductUserExternalAccountByAccountId(ref CopyProductUserExternalAccountByAccountIdOptions options, out ExternalAccountInfo? outExternalAccountInfo)
		{
			var optionsInternal = default(CopyProductUserExternalAccountByAccountIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outExternalAccountInfoPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Connect_CopyProductUserExternalAccountByAccountId(InnerHandle, ref optionsInternal, out outExternalAccountInfoPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoPointer, out outExternalAccountInfo);
			if (outExternalAccountInfoPointer != IntPtr.Zero)
			{
				Bindings.EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetch information about an external account of a specific type linked to a Product User ID.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the target external account type.
		/// </param>
		/// <param name="outExternalAccountInfo">
		/// The external account info data for the user with given external account type.
		/// </param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo.
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo.
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter.
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet.
		/// </returns>
		public Result CopyProductUserExternalAccountByAccountType(ref CopyProductUserExternalAccountByAccountTypeOptions options, out ExternalAccountInfo? outExternalAccountInfo)
		{
			var optionsInternal = default(CopyProductUserExternalAccountByAccountTypeOptionsInternal);
			optionsInternal.Set(ref options);

			var outExternalAccountInfoPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Connect_CopyProductUserExternalAccountByAccountType(InnerHandle, ref optionsInternal, out outExternalAccountInfoPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoPointer, out outExternalAccountInfo);
			if (outExternalAccountInfoPointer != IntPtr.Zero)
			{
				Bindings.EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetch information about an external account linked to a Product User ID.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the target index.
		/// </param>
		/// <param name="outExternalAccountInfo">
		/// The external account info data for the user with given index.
		/// </param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo.
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo.
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter.
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet.
		/// </returns>
		public Result CopyProductUserExternalAccountByIndex(ref CopyProductUserExternalAccountByIndexOptions options, out ExternalAccountInfo? outExternalAccountInfo)
		{
			var optionsInternal = default(CopyProductUserExternalAccountByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outExternalAccountInfoPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Connect_CopyProductUserExternalAccountByIndex(InnerHandle, ref optionsInternal, out outExternalAccountInfoPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoPointer, out outExternalAccountInfo);
			if (outExternalAccountInfoPointer != IntPtr.Zero)
			{
				Bindings.EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetch information about a Product User, using the external account that they most recently logged in with as the reference.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the target external account ID.
		/// </param>
		/// <param name="outExternalAccountInfo">
		/// The external account info data last logged in for the user.
		/// </param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo.
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo.
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter.
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet.
		/// </returns>
		public Result CopyProductUserInfo(ref CopyProductUserInfoOptions options, out ExternalAccountInfo? outExternalAccountInfo)
		{
			var optionsInternal = default(CopyProductUserInfoOptionsInternal);
			optionsInternal.Set(ref options);

			var outExternalAccountInfoPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Connect_CopyProductUserInfo(InnerHandle, ref optionsInternal, out outExternalAccountInfoPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoPointer, out outExternalAccountInfo);
			if (outExternalAccountInfoPointer != IntPtr.Zero)
			{
				Bindings.EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Create a new unique pseudo-account that can be used to identify the current user profile on the local device.
		/// 
		/// This function is intended to be used by mobile games and PC games that wish to allow
		/// a new user to start playing without requiring to login to the game using any user identity.
		/// In addition to this, the Device ID feature is used to automatically login the local user
		/// also when they have linked at least one external user account(s) with the local Device ID.
		/// 
		/// It is possible to link many devices with the same user's account keyring using the Device ID feature.
		/// 
		/// Linking a device later or immediately with a real user account will ensure that the player
		/// will not lose their progress if they switch devices or lose the device at some point,
		/// as they will be always able to login with one of their linked real accounts and also link
		/// another new device with the user account associations keychain. Otherwise, without having
		/// at least one permanent user account linked to the Device ID, the player would lose all of their
		/// game data and progression permanently should something happen to their device or the local
		/// user profile on the device.
		/// 
		/// After a successful one-time CreateDeviceId operation, the game can login the local user
		/// automatically on subsequent game starts with <see cref="Login" /> using the <see cref="ExternalCredentialType.DeviceidAccessToken" />
		/// credentials type. If a Device ID already exists for the local user on the device then <see cref="Result.DuplicateNotAllowed" />
		/// error result is returned and the caller should proceed to calling <see cref="Login" /> directly.
		/// </summary>
		/// <param name="options">
		/// structure containing operation input parameters.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the create operation completes, either successfully or in error.
		/// </param>
		public void CreateDeviceId(ref CreateDeviceIdOptions options, object clientData, OnCreateDeviceIdCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(CreateDeviceIdOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Connect_CreateDeviceId(InnerHandle, ref optionsInternal, clientDataPointer, OnCreateDeviceIdCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Create an account association with the Epic Online Service as a product user given their external auth credentials.
		/// </summary>
		/// <param name="options">
		/// structure containing a continuance token from a "user not found" response during Login (always try login first).
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the create operation completes, either successfully or in error.
		/// </param>
		public void CreateUser(ref CreateUserOptions options, object clientData, OnCreateUserCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(CreateUserOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Connect_CreateUser(InnerHandle, ref optionsInternal, clientDataPointer, OnCreateUserCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Delete any existing Device ID access credentials for the current user profile on the local device.
		/// 
		/// The deletion is permanent and it is not possible to recover lost game data and progression
		/// if the Device ID had not been linked with at least one real external user account.
		/// 
		/// On Android and iOS devices, uninstalling the application will automatically delete any local
		/// Device ID credentials created by the application.
		/// 
		/// On Desktop platforms (Linux, macOS, Windows), Device ID credentials are not automatically deleted.
		/// Applications may re-use existing Device ID credentials for the local OS user when the application is
		/// re-installed, or call the DeleteDeviceId API on the first run to ensure a fresh start for the user.
		/// </summary>
		/// <param name="options">
		/// structure containing operation input parameters
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the delete operation completes, either successfully or in error
		/// </param>
		public void DeleteDeviceId(ref DeleteDeviceIdOptions options, object clientData, OnDeleteDeviceIdCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(DeleteDeviceIdOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Connect_DeleteDeviceId(InnerHandle, ref optionsInternal, clientDataPointer, OnDeleteDeviceIdCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Fetch a Product User ID that maps to an external account ID cached from a previous query.
		/// </summary>
		/// <param name="options">
		/// structure containing the local user and target external account ID.
		/// </param>
		/// <returns>
		/// The Product User ID, previously retrieved from the backend service, for the given target external account.
		/// </returns>
		public ProductUserId GetExternalAccountMapping(ref GetExternalAccountMappingsOptions options)
		{
			var optionsInternal = default(GetExternalAccountMappingsOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Connect_GetExternalAccountMapping(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			ProductUserId callResultReturn;
			Helper.Get(callResult, out callResultReturn);
			return callResultReturn;
		}

		/// <summary>
		/// Fetch a Product User ID that is logged in. This Product User ID is in the Epic Online Services namespace.
		/// </summary>
		/// <param name="index">
		/// an index into the list of logged in users. If the index is out of bounds, the returned Product User ID will be invalid.
		/// </param>
		/// <returns>
		/// the Product User ID associated with the index passed.
		/// </returns>
		public ProductUserId GetLoggedInUserByIndex(int index)
		{
			var callResult = Bindings.EOS_Connect_GetLoggedInUserByIndex(InnerHandle, index);

			ProductUserId callResultReturn;
			Helper.Get(callResult, out callResultReturn);
			return callResultReturn;
		}

		/// <summary>
		/// Fetch the number of product users that are logged in.
		/// </summary>
		/// <returns>
		/// the number of product users logged in.
		/// </returns>
		public int GetLoggedInUsersCount()
		{
			var callResult = Bindings.EOS_Connect_GetLoggedInUsersCount(InnerHandle);

			return callResult;
		}

		/// <summary>
		/// Fetches the login status for an Product User ID. This Product User ID is considered logged in as long as the underlying access token has not expired.
		/// </summary>
		/// <param name="localUserId">
		/// the Product User ID of the user being queried.
		/// </param>
		/// <returns>
		/// the enum value of a user's login status.
		/// </returns>
		public LoginStatus GetLoginStatus(ProductUserId localUserId)
		{
			var callResult = Bindings.EOS_Connect_GetLoginStatus(InnerHandle, localUserId.InnerHandle);

			return callResult;
		}

		/// <summary>
		/// Fetch the number of linked external accounts for a Product User ID.
		/// <see cref="CopyProductUserExternalAccountByIndex" />
		/// </summary>
		/// <param name="options">
		/// The Options associated with retrieving the external account info count.
		/// </param>
		/// <returns>
		/// Number of external accounts or 0 otherwise.
		/// </returns>
		public uint GetProductUserExternalAccountCount(ref GetProductUserExternalAccountCountOptions options)
		{
			var optionsInternal = default(GetProductUserExternalAccountCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Connect_GetProductUserExternalAccountCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Fetch an external account ID, in <see cref="Utf8String" /> form, that maps to a given Product User ID.
		/// </summary>
		/// <param name="options">
		/// structure containing the local user and target Product User ID.
		/// </param>
		/// <param name="outBuffer">
		/// The buffer into which the external account ID data should be written. The buffer must be long enough to hold a <see cref="Utf8String" /> of <see cref="EXTERNAL_ACCOUNT_ID_MAX_LENGTH" />.
		/// </param>
		/// <param name="inOutBufferLength">
		/// The size of the OutBuffer in characters.
		/// The input buffer should include enough space to be <see langword="null" />-terminated.
		/// When the function returns, this parameter will be filled with the length of the <see cref="Utf8String" /> copied into OutBuffer.
		/// </param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account ID was copied into the OutBuffer.
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserInfo.
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter.
		/// <see cref="Result.NotFound" /> if the mapping doesn't exist or hasn't been queried yet.
		/// <see cref="Result.LimitExceeded" /> if the OutBuffer is not large enough to receive the external account ID. InOutBufferLength contains the required minimum length to perform the operation successfully.
		/// </returns>
		public Result GetProductUserIdMapping(ref GetProductUserIdMappingOptions options, out Utf8String outBuffer)
		{
			var optionsInternal = default(GetProductUserIdMappingOptionsInternal);
			optionsInternal.Set(ref options);

			int inOutBufferLength = EXTERNAL_ACCOUNT_ID_MAX_LENGTH + 1;
			var outBufferPointer = Helper.AddAllocation(inOutBufferLength);

			var callResult = Bindings.EOS_Connect_GetProductUserIdMapping(InnerHandle, ref optionsInternal, outBufferPointer, ref inOutBufferLength);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outBufferPointer, out outBuffer);
			Helper.Dispose(ref outBufferPointer);

			return callResult;
		}

		/// <summary>
		/// Link a set of external auth credentials with an existing product user on the Epic Online Service.
		/// </summary>
		/// <param name="options">
		/// structure containing a continuance token from a "user not found" response during Login (always try login first) and a currently logged in user not already associated with this external auth provider.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the link operation completes, either successfully or in error.
		/// </param>
		public void LinkAccount(ref LinkAccountOptions options, object clientData, OnLinkAccountCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(LinkAccountOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Connect_LinkAccount(InnerHandle, ref optionsInternal, clientDataPointer, OnLinkAccountCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Login/Authenticate given a valid set of external auth credentials.
		/// </summary>
		/// <param name="options">
		/// structure containing the external account credentials and type to use during the login operation.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the login operation completes, either successfully or in error.
		/// </param>
		public void Login(ref LoginOptions options, object clientData, OnLoginCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(LoginOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Connect_Login(InnerHandle, ref optionsInternal, clientDataPointer, OnLoginCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Logout a currently logged in user.
		/// NOTE: Access tokens for Product User IDs cannot be revoked. This operation really just cleans up state for the Product User ID and locally discards any associated access token.
		/// </summary>
		/// <param name="options">
		/// Structure containing the input parameters for the operation
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to the caller in the CompletionDelegate.
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the operation completes, either successfully or in error.
		/// </param>
		public void Logout(ref LogoutOptions options, object clientData, OnLogoutCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(LogoutOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Connect_Logout(InnerHandle, ref optionsInternal, clientDataPointer, OnLogoutCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Retrieve the equivalent Product User IDs from a list of external account IDs from supported account providers.
		/// The values will be cached and retrievable through <see cref="GetExternalAccountMapping" />.
		/// A common use case is to query other users who are connected through the same account system as the local user.
		/// Queries using external account IDs of another account system may not be available, depending on the account system specifics.
		/// </summary>
		/// <param name="options">
		/// structure containing a list of external account IDs, in <see cref="Utf8String" /> form, to query for the Product User ID representation.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the query operation completes, either successfully or in error.
		/// </param>
		public void QueryExternalAccountMappings(ref QueryExternalAccountMappingsOptions options, object clientData, OnQueryExternalAccountMappingsCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryExternalAccountMappingsOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Connect_QueryExternalAccountMappings(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryExternalAccountMappingsCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Retrieve the equivalent external account mappings from a list of Product User IDs.
		/// 
		/// The values will be cached and retrievable via <see cref="GetProductUserIdMapping" />, <see cref="CopyProductUserExternalAccountByIndex" />,
		/// <see cref="CopyProductUserExternalAccountByAccountType" /> or <see cref="CopyProductUserExternalAccountByAccountId" />.
		/// <see cref="ExternalAccountInfo" />
		/// <see cref="GetProductUserExternalAccountCount" />
		/// <see cref="GetProductUserIdMapping" />
		/// <see cref="CopyProductUserExternalAccountByIndex" />
		/// <see cref="CopyProductUserExternalAccountByAccountType" />
		/// <see cref="CopyProductUserExternalAccountByAccountId" />
		/// <see cref="CopyProductUserInfo" />
		/// </summary>
		/// <param name="options">
		/// structure containing a list of Product User IDs to query for the external account representation.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the query operation completes, either successfully or in error.
		/// </param>
		public void QueryProductUserIdMappings(ref QueryProductUserIdMappingsOptions options, object clientData, OnQueryProductUserIdMappingsCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryProductUserIdMappingsOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Connect_QueryProductUserIdMappings(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryProductUserIdMappingsCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Unregister from receiving expiration notifications.
		/// </summary>
		/// <param name="inId">
		/// handle representing the registered callback.
		/// </param>
		public void RemoveNotifyAuthExpiration(ulong inId)
		{
			Bindings.EOS_Connect_RemoveNotifyAuthExpiration(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving user login status updates.
		/// </summary>
		/// <param name="inId">
		/// handle representing the registered callback.
		/// </param>
		public void RemoveNotifyLoginStatusChanged(ulong inId)
		{
			Bindings.EOS_Connect_RemoveNotifyLoginStatusChanged(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Transfer a Device ID pseudo-account and the product user associated with it into another
		/// keychain linked with real user accounts (such as Epic Games, PlayStation(TM)Network, Xbox Live, and other).
		/// 
		/// This function allows transferring a product user, i.e. the local user's game progression
		/// backend data from a Device ID owned keychain into a keychain with real user accounts
		/// linked to it. The transfer of Device ID owned product user into a keychain of real user
		/// accounts allows persisting the user's game data on the backend in the event that they
		/// would lose access to the local device or otherwise switch to another device or platform.
		/// 
		/// This function is only applicable in the situation of where the local user first plays
		/// the game using the anonymous Device ID login, then later logs in using a real user
		/// account that they have also already used to play the same game or another game under the
		/// same organization within Epic Online Services. In such situation, while normally the login
		/// attempt with a real user account would return <see cref="Result.InvalidUser" /> and an <see cref="ContinuanceToken" />
		/// and allow calling the <see cref="LinkAccount" /> API to link it with the Device ID's keychain,
		/// instead the login operation succeeds and finds an existing user because the association
		/// already exists. Because the user cannot have two product users simultaneously to play with,
		/// the game should prompt the user to choose which profile to keep and which one to discard
		/// permanently. Based on the user choice, the game may then proceed to transfer the Device ID
		/// login into the keychain that is persistent and backed by real user accounts, and if the user
		/// chooses so, move the product user as well into the destination keychain and overwrite the
		/// existing previous product user with it. To clarify, moving the product user with the Device ID
		/// login in this way into a persisted keychain allows to preserve the so far only locally persisted
		/// game progression and thus protect the user against a case where they lose access to the device.
		/// 
		/// On success, the completion callback will return the preserved <see cref="ProductUserId" /> that remains
		/// logged in while the discarded <see cref="ProductUserId" /> has been invalidated and deleted permanently.
		/// Consecutive logins using the existing Device ID login type or the external account will
		/// connect the user to the same backend data belonging to the preserved <see cref="ProductUserId" />.
		/// 
		/// Example walkthrough: Cross-platform mobile game using the anonymous Device ID login.
		/// 
		/// For onboarding new users, the game will attempt to always automatically login the local user
		/// by calling <see cref="Login" /> using the <see cref="ExternalCredentialType.DeviceidAccessToken" /> login type. If the local
		/// Device ID credentials are not found, and the game wants a frictionless entry for the first time
		/// user experience, the game will automatically call <see cref="CreateDeviceId" /> to create new
		/// Device ID pseudo-account and then login the local user into it. Consecutive game starts will
		/// thus automatically login the user to their locally persisted Device ID account.
		/// 
		/// The user starts playing anonymously using the Device ID login type and makes significant game progress.
		/// Later, they login using an external account that they have already used previously for the
		/// same game perhaps on another platform, or another game owned by the same organization.
		/// In such case, <see cref="Login" /> will automatically login the user to their existing account
		/// linking keychain and create automatically a new empty product user for this product.
		/// 
		/// In order for the user to use their existing previously created keychain and have the locally
		/// created Device ID login reference to that keychain instead, the user's current product user
		/// needs to be moved to be under that keychain so that their existing game progression will be
		/// preserved. To do so, the game can call <see cref="TransferDeviceIdAccount" /> to transfer the
		/// Device ID login and the product user associated with it into the other keychain that has real
		/// external user account(s) linked to it. Note that it is important that the game either automatically
		/// checks that the other product user does not have any meaningful progression data, or otherwise
		/// will prompt the user to make the choice on which game progression to preserve and which can
		/// be discarded permanently. The other product user will be discarded permanently and cannot be
		/// recovered, so it is very important that the user is guided to make the right choice to avoid
		/// accidental loss of all game progression.
		/// <see cref="Login" />
		/// <see cref="CreateDeviceId" />
		/// </summary>
		/// <param name="options">
		/// structure containing the logged in product users and specifying which one will be preserved.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the transfer operation completes, either successfully or in error.
		/// </param>
		public void TransferDeviceIdAccount(ref TransferDeviceIdAccountOptions options, object clientData, OnTransferDeviceIdAccountCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(TransferDeviceIdAccountOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Connect_TransferDeviceIdAccount(InnerHandle, ref optionsInternal, clientDataPointer, OnTransferDeviceIdAccountCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Unlink external auth credentials from the owning keychain of a logged in product user.
		/// 
		/// This function allows recovering the user from scenarios where they have accidentally proceeded to creating
		/// a new product user for the local native user account, instead of linking it with an existing keychain that
		/// they have previously created by playing the game (or another game owned by the organization) on another platform.
		/// 
		/// In such scenario, after the initial platform login and a new product user creation, the user wishes to re-login
		/// using other set of external auth credentials to connect with their existing game progression data. In order to
		/// allow automatic login also on the current platform, they will need to unlink the accidentally created new keychain
		/// and product user and then use the <see cref="Login" /> and <see cref="LinkAccount" /> APIs to link the local native platform
		/// account with that previously created existing product user and its owning keychain.
		/// 
		/// In another scenario, the user may simply want to disassociate the account that they have logged in with from the current
		/// keychain that it is linked with, perhaps to link it against another keychain or to separate the game progressions again.
		/// 
		/// In order to protect against account theft, it is only possible to unlink user accounts that have been authenticated
		/// and logged in to the product user in the current session. This prevents a malicious actor from gaining access to one
		/// of the linked accounts and using it to remove all other accounts linked with the keychain. This also prevents a malicious
		/// actor from replacing the unlinked account with their own corresponding account on the same platform, as the unlinking
		/// operation will ensure that any existing authentication session cannot be used to re-link and overwrite the entry without
		/// authenticating with one of the other linked accounts in the keychain. These restrictions limit the potential attack surface
		/// related to account theft scenarios.
		/// </summary>
		/// <param name="options">
		/// structure containing operation input parameters.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the unlink operation completes, either successfully or in error.
		/// </param>
		public void UnlinkAccount(ref UnlinkAccountOptions options, object clientData, OnUnlinkAccountCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(UnlinkAccountOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Connect_UnlinkAccount(InnerHandle, ref optionsInternal, clientDataPointer, OnUnlinkAccountCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Verify a given ID token for authenticity and validity.
		/// </summary>
		/// <param name="options">
		/// structure containing information about the ID token to verify.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the callback.
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the operation completes, either successfully or in error.
		/// </param>
		public void VerifyIdToken(ref VerifyIdTokenOptions options, object clientData, OnVerifyIdTokenCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(VerifyIdTokenOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Connect_VerifyIdToken(InnerHandle, ref optionsInternal, clientDataPointer, OnVerifyIdTokenCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}
	}
}

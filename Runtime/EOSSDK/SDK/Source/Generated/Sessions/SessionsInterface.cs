// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.Sessions
{
	public sealed partial class SessionsInterface : Handle
	{
		public SessionsInterface()
		{
		}

		public SessionsInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="ActiveSession.CopyInfo" /> function.
		/// </summary>
		public const int ACTIVESESSION_COPYINFO_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="ActiveSession.GetRegisteredPlayerByIndex" /> function.
		/// </summary>
		public const int ACTIVESESSION_GETREGISTEREDPLAYERBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="ActiveSession.GetRegisteredPlayerCount" /> function.
		/// </summary>
		public const int ACTIVESESSION_GETREGISTEREDPLAYERCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="ActiveSessionInfo" /> struct.
		/// </summary>
		public const int ACTIVESESSION_INFO_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyJoinSessionAccepted" /> API.
		/// </summary>
		public const int ADDNOTIFYJOINSESSIONACCEPTED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLeaveSessionRequested" /> API.
		/// </summary>
		public const int ADDNOTIFYLEAVESESSIONREQUESTED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifySendSessionNativeInviteRequested" /> API.
		/// </summary>
		public const int ADDNOTIFYSENDSESSIONNATIVEINVITEREQUESTED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifySessionInviteAccepted" /> API.
		/// </summary>
		public const int ADDNOTIFYSESSIONINVITEACCEPTED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifySessionInviteReceived" /> API.
		/// </summary>
		public const int ADDNOTIFYSESSIONINVITERECEIVED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifySessionInviteAccepted" /> API.
		/// </summary>
		public const int ADDNOTIFYSESSIONINVITEREJECTED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AttributeData" /> struct.
		/// </summary>
		public const int ATTRIBUTEDATA_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyActiveSessionHandle" /> API.
		/// </summary>
		public const int COPYACTIVESESSIONHANDLE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopySessionHandleByInviteId" /> API.
		/// </summary>
		public const int COPYSESSIONHANDLEBYINVITEID_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopySessionHandleByUiEventId" /> API.
		/// </summary>
		public const int COPYSESSIONHANDLEBYUIEVENTID_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopySessionHandleForPresence" /> API.
		/// </summary>
		public const int COPYSESSIONHANDLEFORPRESENCE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CreateSessionModification" /> API.
		/// </summary>
		public const int CREATESESSIONMODIFICATION_API_LATEST = 5;
		/// <summary>
		/// The most recent version of the <see cref="CreateSessionSearch" /> API.
		/// </summary>
		public const int CREATESESSIONSEARCH_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="DestroySession" /> API.
		/// </summary>
		public const int DESTROYSESSION_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="DumpSessionState" /> API.
		/// </summary>
		public const int DUMPSESSIONSTATE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="EndSession" /> API.
		/// </summary>
		public const int ENDSESSION_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetInviteCount" /> API.
		/// </summary>
		public const int GETINVITECOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetInviteIdByIndex" /> API.
		/// </summary>
		public const int GETINVITEIDBYINDEX_API_LATEST = 1;
		/// <summary>
		/// Max length of an invite ID
		/// </summary>
		public const int INVITEID_MAX_LENGTH = 64;
		/// <summary>
		/// The most recent version of the <see cref="IsUserInSession" /> API.
		/// </summary>
		public const int ISUSERINSESSION_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="JoinSession" /> API.
		/// </summary>
		public const int JOINSESSION_API_LATEST = 2;
		/// <summary>
		/// Maximum number of players allowed in a single session
		/// </summary>
		public const int MAXREGISTEREDPLAYERS = 1000;
		/// <summary>
		/// Maximum number of search results allowed with a given query
		/// </summary>
		public const int MAX_SEARCH_RESULTS = 200;
		/// <summary>
		/// The most recent version of the <see cref="QueryInvites" /> API.
		/// </summary>
		public const int QUERYINVITES_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="RegisterPlayers" /> API.
		/// </summary>
		public const int REGISTERPLAYERS_API_LATEST = 3;
		/// <summary>
		/// The most recent version of the <see cref="RejectInvite" /> API.
		/// </summary>
		public const int REJECTINVITE_API_LATEST = 1;
		/// <summary>
		/// Search for a matching bucket ID (value is <see cref="Utf8String" />)
		/// </summary>
		public static readonly Utf8String SEARCH_BUCKET_ID = "bucket";
		/// <summary>
		/// Search for empty servers only (value is <see langword="true" />/<see langword="false" />)
		/// </summary>
		public static readonly Utf8String SEARCH_EMPTY_SERVERS_ONLY = "emptyonly";
		/// <summary>
		/// Search for a match with min free space (value is int)
		/// </summary>
		public static readonly Utf8String SEARCH_MINSLOTSAVAILABLE = "minslotsavailable";
		/// <summary>
		/// Search for non empty servers only (value is <see langword="true" />/<see langword="false" />)
		/// </summary>
		public static readonly Utf8String SEARCH_NONEMPTY_SERVERS_ONLY = "nonemptyonly";
		/// <summary>
		/// The most recent version of the <see cref="SendInvite" /> API.
		/// </summary>
		public const int SENDINVITE_API_LATEST = 1;
		/// <summary>
		/// DEPRECATED! Use <see cref="ATTRIBUTEDATA_API_LATEST" /> instead.
		/// </summary>
		public const int SESSIONATTRIBUTEDATA_API_LATEST = ATTRIBUTEDATA_API_LATEST;
		/// <summary>
		/// DEPRECATED! Use <see cref="SESSIONDETAILS_ATTRIBUTE_API_LATEST" /> instead.
		/// </summary>
		public const int SESSIONATTRIBUTE_API_LATEST = SESSIONDETAILS_ATTRIBUTE_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="SessionDetailsAttribute" /> struct.
		/// </summary>
		public const int SESSIONDETAILS_ATTRIBUTE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionDetails.CopyInfo" /> API.
		/// </summary>
		public const int SESSIONDETAILS_COPYINFO_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionDetails.CopySessionAttributeByIndex" /> API.
		/// </summary>
		public const int SESSIONDETAILS_COPYSESSIONATTRIBUTEBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionDetails.CopySessionAttributeByKey" /> API.
		/// </summary>
		public const int SESSIONDETAILS_COPYSESSIONATTRIBUTEBYKEY_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionDetails.GetSessionAttributeCount" /> API.
		/// </summary>
		public const int SESSIONDETAILS_GETSESSIONATTRIBUTECOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionDetailsInfo" /> struct.
		/// </summary>
		public const int SESSIONDETAILS_INFO_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="SessionDetailsSettings" /> struct.
		/// </summary>
		public const int SESSIONDETAILS_SETTINGS_API_LATEST = 4;
		/// <summary>
		/// The most recent version of the <see cref="SessionModification.AddAttribute" /> API.
		/// </summary>
		public const int SESSIONMODIFICATION_ADDATTRIBUTE_API_LATEST = 2;
		/// <summary>
		/// Maximum number of characters allowed in the session id override
		/// </summary>
		public const int SESSIONMODIFICATION_MAX_SESSIONIDOVERRIDE_LENGTH = 64;
		/// <summary>
		/// Maximum number of attributes allowed on the session
		/// </summary>
		public const int SESSIONMODIFICATION_MAX_SESSION_ATTRIBUTES = 64;
		/// <summary>
		/// Maximum length of the name of the attribute associated with the session
		/// </summary>
		public const int SESSIONMODIFICATION_MAX_SESSION_ATTRIBUTE_LENGTH = 64;
		/// <summary>
		/// Minimum number of characters allowed in the session id override
		/// </summary>
		public const int SESSIONMODIFICATION_MIN_SESSIONIDOVERRIDE_LENGTH = 16;
		/// <summary>
		/// The most recent version of the <see cref="SessionModification.RemoveAttribute" /> API.
		/// </summary>
		public const int SESSIONMODIFICATION_REMOVEATTRIBUTE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionModification.SetAllowedPlatformIds" /> API.
		/// </summary>
		public const int SESSIONMODIFICATION_SETALLOWEDPLATFORMIDS_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionModification.SetBucketId" /> API.
		/// </summary>
		public const int SESSIONMODIFICATION_SETBUCKETID_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionModification.SetHostAddress" /> API.
		/// </summary>
		public const int SESSIONMODIFICATION_SETHOSTADDRESS_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionModification.SetInvitesAllowed" /> API.
		/// </summary>
		public const int SESSIONMODIFICATION_SETINVITESALLOWED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionModification.SetJoinInProgressAllowed" /> API.
		/// </summary>
		public const int SESSIONMODIFICATION_SETJOININPROGRESSALLOWED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionModification.SetMaxPlayers" /> API.
		/// </summary>
		public const int SESSIONMODIFICATION_SETMAXPLAYERS_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionModification.SetPermissionLevel" /> API.
		/// </summary>
		public const int SESSIONMODIFICATION_SETPERMISSIONLEVEL_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionSearch.CopySearchResultByIndex" /> API.
		/// </summary>
		public const int SESSIONSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionSearch.Find" /> API.
		/// </summary>
		public const int SESSIONSEARCH_FIND_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="SessionSearch.GetSearchResultCount" /> API.
		/// </summary>
		public const int SESSIONSEARCH_GETSEARCHRESULTCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionSearch.RemoveParameter" /> API.
		/// </summary>
		public const int SESSIONSEARCH_REMOVEPARAMETER_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionSearch.SetMaxResults" /> API.
		/// </summary>
		public const int SESSIONSEARCH_SETMAXSEARCHRESULTS_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionSearch.SetParameter" /> API.
		/// </summary>
		public const int SESSIONSEARCH_SETPARAMETER_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionSearch.SetSessionId" /> API.
		/// </summary>
		public const int SESSIONSEARCH_SETSESSIONID_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="SessionSearch.SetTargetUserId" /> API.
		/// </summary>
		public const int SESSIONSEARCH_SETTARGETUSERID_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="StartSession" /> API.
		/// </summary>
		public const int STARTSESSION_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="UnregisterPlayers" /> API.
		/// </summary>
		public const int UNREGISTERPLAYERS_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="UpdateSessionModification" /> API.
		/// </summary>
		public const int UPDATESESSIONMODIFICATION_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="UpdateSession" /> API.
		/// </summary>
		public const int UPDATESESSION_API_LATEST = 1;

		/// <summary>
		/// Register to receive notifications when a user accepts a session join game via the social overlay.
		/// If the returned NotificationId is valid, you must call <see cref="RemoveNotifyJoinSessionAccepted" /> when you no longer wish to have your NotificationHandler called
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the request.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="notificationFn">
		/// A callback that is fired when a notification is received.
		/// </param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyJoinSessionAccepted(ref AddNotifyJoinSessionAcceptedOptions options, object clientData, OnJoinSessionAcceptedCallback notificationFn)
		{
			if (notificationFn == null)
			{
				throw new ArgumentNullException("notificationFn");
			}

			var optionsInternal = default(AddNotifyJoinSessionAcceptedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notificationFn);

			var callResult = Bindings.EOS_Sessions_AddNotifyJoinSessionAccepted(InnerHandle, ref optionsInternal, clientDataPointer, OnJoinSessionAcceptedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Register to receive notifications about leave session requests performed by local user via the overlay.
		/// When user requests to leave the session in the social overlay, the SDK does not automatically leave the session, it is up to the game to perform any necessary cleanup and call the <see cref="DestroySession" /> method using the SessionName sent in the notification function.
		/// If the returned NotificationId is valid, you must call <see cref="RemoveNotifyLeaveSessionRequested" /> when you no longer wish to have your NotificationHandler called.
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the request.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="notificationFn">
		/// A callback that is fired when a notification is received.
		/// </param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLeaveSessionRequested(ref AddNotifyLeaveSessionRequestedOptions options, object clientData, OnLeaveSessionRequestedCallback notificationFn)
		{
			if (notificationFn == null)
			{
				throw new ArgumentNullException("notificationFn");
			}

			var optionsInternal = default(AddNotifyLeaveSessionRequestedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notificationFn);

			var callResult = Bindings.EOS_Sessions_AddNotifyLeaveSessionRequested(InnerHandle, ref optionsInternal, clientDataPointer, OnLeaveSessionRequestedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Register to receive notifications about a session "INVITE" performed by a local user via the overlay.
		/// This is only needed when a configured integrated platform has <see cref="IntegratedPlatform.IntegratedPlatformManagementFlags.DisableSDKManagedSessions" /> set. The EOS SDK will
		/// then use the state of <see cref="IntegratedPlatform.IntegratedPlatformManagementFlags.PreferEOSIdentity" /> and <see cref="IntegratedPlatform.IntegratedPlatformManagementFlags.PreferIntegratedIdentity" /> to determine when the NotificationFn is
		/// called.
		/// If the returned NotificationId is valid, you must call <see cref="RemoveNotifySendSessionNativeInviteRequested" /> when you no longer wish to have your NotificationHandler called.
		/// <see cref="IntegratedPlatform.IntegratedPlatformManagementFlags.DisableSDKManagedSessions" />
		/// <see cref="IntegratedPlatform.IntegratedPlatformManagementFlags.PreferEOSIdentity" />
		/// <see cref="IntegratedPlatform.IntegratedPlatformManagementFlags.PreferIntegratedIdentity" />
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the request.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="notificationFn">
		/// A callback that is fired when a notification is received.
		/// </param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifySendSessionNativeInviteRequested(ref AddNotifySendSessionNativeInviteRequestedOptions options, object clientData, OnSendSessionNativeInviteRequestedCallback notificationFn)
		{
			if (notificationFn == null)
			{
				throw new ArgumentNullException("notificationFn");
			}

			var optionsInternal = default(AddNotifySendSessionNativeInviteRequestedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notificationFn);

			var callResult = Bindings.EOS_Sessions_AddNotifySendSessionNativeInviteRequested(InnerHandle, ref optionsInternal, clientDataPointer, OnSendSessionNativeInviteRequestedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Register to receive notifications when a user accepts a session invite via the social overlay.
		/// If the returned NotificationId is valid, you must call <see cref="RemoveNotifySessionInviteAccepted" /> when you no longer wish to have your NotificationHandler called.
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the request.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="notificationFn">
		/// A callback that is fired when a a notification is received.
		/// </param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifySessionInviteAccepted(ref AddNotifySessionInviteAcceptedOptions options, object clientData, OnSessionInviteAcceptedCallback notificationFn)
		{
			if (notificationFn == null)
			{
				throw new ArgumentNullException("notificationFn");
			}

			var optionsInternal = default(AddNotifySessionInviteAcceptedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notificationFn);

			var callResult = Bindings.EOS_Sessions_AddNotifySessionInviteAccepted(InnerHandle, ref optionsInternal, clientDataPointer, OnSessionInviteAcceptedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Register to receive session invites.
		/// If the returned NotificationId is valid, you must call <see cref="RemoveNotifySessionInviteReceived" /> when you no longer wish to have your NotificationHandler called.
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the session invite notification
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="notificationFn">
		/// A callback that is fired when a session invite for a user has been received
		/// </param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifySessionInviteReceived(ref AddNotifySessionInviteReceivedOptions options, object clientData, OnSessionInviteReceivedCallback notificationFn)
		{
			if (notificationFn == null)
			{
				throw new ArgumentNullException("notificationFn");
			}

			var optionsInternal = default(AddNotifySessionInviteReceivedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notificationFn);

			var callResult = Bindings.EOS_Sessions_AddNotifySessionInviteReceived(InnerHandle, ref optionsInternal, clientDataPointer, OnSessionInviteReceivedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Register to receive notifications when a user rejects a session invite.
		/// If the returned NotificationId is valid, you must call <see cref="RemoveNotifySessionInviteRejected" /> when you no longer wish to have your NotificationHandler called.
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the request.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="notificationFn">
		/// A callback that is fired when a notification is received.
		/// </param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifySessionInviteRejected(ref AddNotifySessionInviteRejectedOptions options, object clientData, OnSessionInviteRejectedCallback notificationFn)
		{
			if (notificationFn == null)
			{
				throw new ArgumentNullException("notificationFn");
			}

			var optionsInternal = default(AddNotifySessionInviteRejectedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notificationFn);

			var callResult = Bindings.EOS_Sessions_AddNotifySessionInviteRejected(InnerHandle, ref optionsInternal, clientDataPointer, OnSessionInviteRejectedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Create a handle to an existing active session.
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the active session to retrieve
		/// </param>
		/// <param name="outSessionHandle">
		/// The new active session handle or <see langword="null" /> if there was an error
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the session handle was created successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> if the active session doesn't exist
		/// </returns>
		public Result CopyActiveSessionHandle(ref CopyActiveSessionHandleOptions options, out ActiveSession outSessionHandle)
		{
			var optionsInternal = default(CopyActiveSessionHandleOptionsInternal);
			optionsInternal.Set(ref options);

			var outSessionHandleInnerHandle = IntPtr.Zero;

			var callResult = Bindings.EOS_Sessions_CopyActiveSessionHandle(InnerHandle, ref optionsInternal, out outSessionHandleInnerHandle);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outSessionHandleInnerHandle, out outSessionHandle);

			return callResult;
		}

		/// <summary>
		/// <see cref="CopySessionHandleByInviteId" /> is used to immediately retrieve a handle to the session information from after notification of an invite
		/// If the call returns an <see cref="Result.Success" /> result, the out parameter, OutSessionHandle, must be passed to <see cref="SessionDetails.Release" /> to release the memory associated with it.
		/// <see cref="CopySessionHandleByInviteIdOptions" />
		/// <see cref="SessionDetails.Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the input parameters
		/// </param>
		/// <param name="outSessionHandle">
		/// out parameter used to receive the session handle
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutSessionHandle
		/// <see cref="Result.InvalidParameters" /> if you pass an invalid invite ID or a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> if the invite ID cannot be found
		/// </returns>
		public Result CopySessionHandleByInviteId(ref CopySessionHandleByInviteIdOptions options, out SessionDetails outSessionHandle)
		{
			var optionsInternal = default(CopySessionHandleByInviteIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outSessionHandleInnerHandle = IntPtr.Zero;

			var callResult = Bindings.EOS_Sessions_CopySessionHandleByInviteId(InnerHandle, ref optionsInternal, out outSessionHandleInnerHandle);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outSessionHandleInnerHandle, out outSessionHandle);

			return callResult;
		}

		/// <summary>
		/// <see cref="CopySessionHandleByUiEventId" /> is used to immediately retrieve a handle to the session information from after notification of a join game event.
		/// If the call returns an <see cref="Result.Success" /> result, the out parameter, OutSessionHandle, must be passed to <see cref="SessionDetails.Release" /> to release the memory associated with it.
		/// <see cref="CopySessionHandleByUiEventIdOptions" />
		/// <see cref="SessionDetails.Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the input parameters
		/// </param>
		/// <param name="outSessionHandle">
		/// out parameter used to receive the session handle
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutSessionHandle
		/// <see cref="Result.InvalidParameters" /> if you pass an invalid invite ID or a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> if the invite ID cannot be found
		/// </returns>
		public Result CopySessionHandleByUiEventId(ref CopySessionHandleByUiEventIdOptions options, out SessionDetails outSessionHandle)
		{
			var optionsInternal = default(CopySessionHandleByUiEventIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outSessionHandleInnerHandle = IntPtr.Zero;

			var callResult = Bindings.EOS_Sessions_CopySessionHandleByUiEventId(InnerHandle, ref optionsInternal, out outSessionHandleInnerHandle);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outSessionHandleInnerHandle, out outSessionHandle);

			return callResult;
		}

		/// <summary>
		/// <see cref="CopySessionHandleForPresence" /> is used to immediately retrieve a handle to the session information which was marked with bPresenceEnabled on create or join.
		/// If the call returns an <see cref="Result.Success" /> result, the out parameter, OutSessionHandle, must be passed to <see cref="SessionDetails.Release" /> to release the memory associated with it.
		/// <see cref="CopySessionHandleForPresenceOptions" />
		/// <see cref="SessionDetails.Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the input parameters
		/// </param>
		/// <param name="outSessionHandle">
		/// out parameter used to receive the session handle
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutSessionHandle
		/// <see cref="Result.InvalidParameters" /> if you pass an invalid invite ID or a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> if there is no session with bPresenceEnabled
		/// </returns>
		public Result CopySessionHandleForPresence(ref CopySessionHandleForPresenceOptions options, out SessionDetails outSessionHandle)
		{
			var optionsInternal = default(CopySessionHandleForPresenceOptionsInternal);
			optionsInternal.Set(ref options);

			var outSessionHandleInnerHandle = IntPtr.Zero;

			var callResult = Bindings.EOS_Sessions_CopySessionHandleForPresence(InnerHandle, ref optionsInternal, out outSessionHandleInnerHandle);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outSessionHandleInnerHandle, out outSessionHandle);

			return callResult;
		}

		/// <summary>
		/// Creates a session modification handle (<see cref="SessionModification" />). The session modification handle is used to build a new session and can be applied with <see cref="UpdateSession" />
		/// The <see cref="SessionModification" /> must be released by calling <see cref="SessionModification.Release" /> once it no longer needed.
		/// <see cref="SessionModification.Release" />
		/// <see cref="UpdateSession" />
		/// <see cref="SessionModification" />
		/// </summary>
		/// <param name="options">
		/// Required fields for the creation of a session such as a name, bucketid, and max players
		/// </param>
		/// <param name="outSessionModificationHandle">
		/// <see cref="IntPtr" /> to a Session Modification Handle only set if successful
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if we successfully created the Session Modification Handle pointed at in OutSessionModificationHandle, or an error result if the input data was invalid
		/// </returns>
		public Result CreateSessionModification(ref CreateSessionModificationOptions options, out SessionModification outSessionModificationHandle)
		{
			var optionsInternal = default(CreateSessionModificationOptionsInternal);
			optionsInternal.Set(ref options);

			var outSessionModificationHandleInnerHandle = IntPtr.Zero;

			var callResult = Bindings.EOS_Sessions_CreateSessionModification(InnerHandle, ref optionsInternal, out outSessionModificationHandleInnerHandle);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outSessionModificationHandleInnerHandle, out outSessionModificationHandle);

			return callResult;
		}

		/// <summary>
		/// Create a session search handle. This handle may be modified to include various search parameters.
		/// Searching is possible in three methods, all mutually exclusive
		/// - set the session ID to find a specific session
		/// - set the target user ID to find a specific user
		/// - set session parameters to find an array of sessions that match the search criteria
		/// </summary>
		/// <param name="options">
		/// Structure containing required parameters such as the maximum number of search results
		/// </param>
		/// <param name="outSessionSearchHandle">
		/// The new search handle or <see langword="null" /> if there was an error creating the search handle
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the search creation completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public Result CreateSessionSearch(ref CreateSessionSearchOptions options, out SessionSearch outSessionSearchHandle)
		{
			var optionsInternal = default(CreateSessionSearchOptionsInternal);
			optionsInternal.Set(ref options);

			var outSessionSearchHandleInnerHandle = IntPtr.Zero;

			var callResult = Bindings.EOS_Sessions_CreateSessionSearch(InnerHandle, ref optionsInternal, out outSessionSearchHandleInnerHandle);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outSessionSearchHandleInnerHandle, out outSessionSearchHandle);

			return callResult;
		}

		/// <summary>
		/// Destroy a session given a session name
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the session to be destroyed
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the destroy operation completes, either successfully or in error
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the destroy completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.AlreadyPending" /> if the session is already marked for destroy
		/// <see cref="Result.NotFound" /> if a session to be destroyed does not exist
		/// </returns>
		public void DestroySession(ref DestroySessionOptions options, object clientData, OnDestroySessionCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(DestroySessionOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Sessions_DestroySession(InnerHandle, ref optionsInternal, clientDataPointer, OnDestroySessionCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Dump the contents of active sessions that exist locally to the log output, purely for debug purposes
		/// </summary>
		/// <param name="options">
		/// Options related to dumping session state such as the session name
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the output operation completes successfully
		/// <see cref="Result.NotFound" /> if the session specified does not exist
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// </returns>
		public Result DumpSessionState(ref DumpSessionStateOptions options)
		{
			var optionsInternal = default(DumpSessionStateOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Sessions_DumpSessionState(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Mark a session as ended, making it available to find if "join in progress" was disabled. The session may be started again if desired
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the session to be ended
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the end operation completes, either successfully or in error
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the end completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.SessionsOutOfSync" /> if the session is out of sync and will be updated on the next connection with the backend
		/// <see cref="Result.NotFound" /> if a session to be ended does not exist
		/// </returns>
		public void EndSession(ref EndSessionOptions options, object clientData, OnEndSessionCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(EndSessionOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Sessions_EndSession(InnerHandle, ref optionsInternal, clientDataPointer, OnEndSessionCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Get the number of known invites for a given user
		/// </summary>
		/// <param name="options">
		/// the Options associated with retrieving the current invite count
		/// </param>
		/// <returns>
		/// number of known invites for a given user or 0 if there is an error
		/// </returns>
		public uint GetInviteCount(ref GetInviteCountOptions options)
		{
			var optionsInternal = default(GetInviteCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Sessions_GetInviteCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Retrieve an invite ID from a list of active invites for a given user
		/// <see cref="GetInviteCount" />
		/// <see cref="CopySessionHandleByInviteId" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the input parameters
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the input is valid and an invite ID was returned
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.NotFound" /> if the invite doesn't exist
		/// </returns>
		public Result GetInviteIdByIndex(ref GetInviteIdByIndexOptions options, out Utf8String outBuffer)
		{
			var optionsInternal = default(GetInviteIdByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			int inOutBufferLength = INVITEID_MAX_LENGTH + 1;
			var outBufferPointer = Helper.AddAllocation(inOutBufferLength);

			var callResult = Bindings.EOS_Sessions_GetInviteIdByIndex(InnerHandle, ref optionsInternal, outBufferPointer, ref inOutBufferLength);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outBufferPointer, out outBuffer);
			Helper.Dispose(ref outBufferPointer);

			return callResult;
		}

		/// <summary>
		/// <see cref="IsUserInSession" /> returns whether or not a given user can be found in a specified session
		/// </summary>
		/// <param name="options">
		/// Structure containing the input parameters
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the user is found in the specified session
		/// <see cref="Result.NotFound" /> if the user is not found in the specified session
		/// <see cref="Result.InvalidParameters" /> if you pass an invalid invite ID or a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.InvalidProductUserID" /> if an invalid target user is specified
		/// <see cref="Result.SessionsInvalidSession" /> if the session specified is invalid
		/// </returns>
		public Result IsUserInSession(ref IsUserInSessionOptions options)
		{
			var optionsInternal = default(IsUserInSessionOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Sessions_IsUserInSession(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Join a session, creating a local session under a given session name. Backend will validate various conditions to make sure it is possible to join the session.
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the session to be joined
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the join operation completes, either successfully or in error
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the join completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.SessionsSessionAlreadyExists" /> if the session is already exists or is in the process of being joined
		/// <see cref="Result.InvalidUser" /> if the local user associated with the local session to be created does not exist or is not authenticated
		/// </returns>
		public void JoinSession(ref JoinSessionOptions options, object clientData, OnJoinSessionCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(JoinSessionOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Sessions_JoinSession(InnerHandle, ref optionsInternal, clientDataPointer, OnJoinSessionCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Retrieve all existing invites for a single user
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the invites to query
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the query invites operation completes, either successfully or in error
		/// </param>
		public void QueryInvites(ref QueryInvitesOptions options, object clientData, OnQueryInvitesCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryInvitesOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Sessions_QueryInvites(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryInvitesCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Register a group of players with the session, allowing them to invite others or otherwise indicate they are part of the session for determining a full session
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the session and players to be registered
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the registration operation completes, either successfully or in error
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the register completes successfully
		/// <see cref="Result.NoChange" /> if the players to register registered previously
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.SessionsOutOfSync" /> if the session is out of sync and will be updated on the next connection with the backend
		/// <see cref="Result.NotFound" /> if a session to register players does not exist
		/// <see cref="Result.LimitExceeded" /> if registering the requested players would drive the total number of registered players beyond <see cref="MAXREGISTEREDPLAYERS" /> (API Version equal to or less than 2)
		/// <see cref="Result.SessionsTooManyPlayers" /> if registering the requested players would drive the total number of registered players beyond <see cref="MAXREGISTEREDPLAYERS" /> (API Version greater than 2)
		/// </returns>
		public void RegisterPlayers(ref RegisterPlayersOptions options, object clientData, OnRegisterPlayersCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(RegisterPlayersOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Sessions_RegisterPlayers(InnerHandle, ref optionsInternal, clientDataPointer, OnRegisterPlayersCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Reject an invite from another player.
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the invite to reject
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the reject invite operation completes, either successfully or in error
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the invite rejection completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.NotFound" /> if the invite does not exist
		/// </returns>
		public void RejectInvite(ref RejectInviteOptions options, object clientData, OnRejectInviteCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(RejectInviteOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Sessions_RejectInvite(InnerHandle, ref optionsInternal, clientDataPointer, OnRejectInviteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user accepts a session join game via the social overlay.
		/// </summary>
		/// <param name="inId">
		/// Handle representing the registered callback
		/// </param>
		public void RemoveNotifyJoinSessionAccepted(ulong inId)
		{
			Bindings.EOS_Sessions_RemoveNotifyJoinSessionAccepted(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user performs a leave lobby action via the overlay.
		/// </summary>
		/// <param name="inId">
		/// Handle representing the registered callback
		/// </param>
		public void RemoveNotifyLeaveSessionRequested(ulong inId)
		{
			Bindings.EOS_Sessions_RemoveNotifyLeaveSessionRequested(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user requests a send invite via the overlay.
		/// </summary>
		/// <param name="inId">
		/// Handle representing the registered callback
		/// </param>
		public void RemoveNotifySendSessionNativeInviteRequested(ulong inId)
		{
			Bindings.EOS_Sessions_RemoveNotifySendSessionNativeInviteRequested(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user accepts a session invite via the social overlay.
		/// </summary>
		/// <param name="inId">
		/// Handle representing the registered callback
		/// </param>
		public void RemoveNotifySessionInviteAccepted(ulong inId)
		{
			Bindings.EOS_Sessions_RemoveNotifySessionInviteAccepted(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving session invites.
		/// </summary>
		/// <param name="inId">
		/// Handle representing the registered callback
		/// </param>
		public void RemoveNotifySessionInviteReceived(ulong inId)
		{
			Bindings.EOS_Sessions_RemoveNotifySessionInviteReceived(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Unregister from receiving notifications when a user rejects a session invite via the social overlay.
		/// </summary>
		/// <param name="inId">
		/// Handle representing the registered callback
		/// </param>
		public void RemoveNotifySessionInviteRejected(ulong inId)
		{
			Bindings.EOS_Sessions_RemoveNotifySessionInviteRejected(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Send an invite to another player. User must have created the session or be registered in the session or else the call will fail
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the session and player to invite
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the send invite operation completes, either successfully or in error
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the send invite completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.NotFound" /> if the session to send the invite from does not exist
		/// </returns>
		public void SendInvite(ref SendInviteOptions options, object clientData, OnSendInviteCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(SendInviteOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Sessions_SendInvite(InnerHandle, ref optionsInternal, clientDataPointer, OnSendInviteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Mark a session as started, making it unable to find if session properties indicate "join in progress" is not available
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the session to be started
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the start operation completes, either successfully or in error
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the start completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.SessionsOutOfSync" /> if the session is out of sync and will be updated on the next connection with the backend
		/// <see cref="Result.NotFound" /> if a session to be started does not exist
		/// </returns>
		public void StartSession(ref StartSessionOptions options, object clientData, OnStartSessionCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(StartSessionOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Sessions_StartSession(InnerHandle, ref optionsInternal, clientDataPointer, OnStartSessionCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Unregister a group of players with the session, freeing up space for others to join
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the session and players to be unregistered
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the unregistration operation completes, either successfully or in error
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the unregister completes successfully
		/// <see cref="Result.NoChange" /> if the players to unregister were not found
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.SessionsOutOfSync" /> if the session is out of sync and will be updated on the next connection with the backend
		/// <see cref="Result.NotFound" /> if a session to be unregister players does not exist
		/// </returns>
		public void UnregisterPlayers(ref UnregisterPlayersOptions options, object clientData, OnUnregisterPlayersCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(UnregisterPlayersOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Sessions_UnregisterPlayers(InnerHandle, ref optionsInternal, clientDataPointer, OnUnregisterPlayersCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Update a session given a session modification handle created by <see cref="CreateSessionModification" /> or <see cref="UpdateSessionModification" />
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the session to be updated
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the update operation completes, either successfully or in error
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the update completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.SessionsOutOfSync" /> if the session is out of sync and will be updated on the next connection with the backend
		/// <see cref="Result.NotFound" /> if a session to be updated does not exist
		/// <see cref="Result.LimitExceeded" /> if a new session cannot be created because doing so would exceed the maximum allowed concurrent session count
		/// <see cref="Result.InvalidUser" /> if the local user associated with the session to update does not exist or is not authenticated
		/// </returns>
		public void UpdateSession(ref UpdateSessionOptions options, object clientData, OnUpdateSessionCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(UpdateSessionOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Sessions_UpdateSession(InnerHandle, ref optionsInternal, clientDataPointer, OnUpdateSessionCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Creates a session modification handle (<see cref="SessionModification" />). The session modification handle is used to modify an existing session and can be applied with <see cref="UpdateSession" />.
		/// The <see cref="SessionModification" /> must be released by calling <see cref="SessionModification.Release" /> once it is no longer needed.
		/// <see cref="SessionModification.Release" />
		/// <see cref="UpdateSession" />
		/// <see cref="SessionModification" />
		/// </summary>
		/// <param name="options">
		/// Required fields such as session name
		/// </param>
		/// <param name="outSessionModificationHandle">
		/// <see cref="IntPtr" /> to a Session Modification Handle only set if successful
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if we successfully created the Session Modification Handle pointed at in OutSessionModificationHandle, or an error result if the input data was invalid
		/// </returns>
		public Result UpdateSessionModification(ref UpdateSessionModificationOptions options, out SessionModification outSessionModificationHandle)
		{
			var optionsInternal = default(UpdateSessionModificationOptionsInternal);
			optionsInternal.Set(ref options);

			var outSessionModificationHandleInnerHandle = IntPtr.Zero;

			var callResult = Bindings.EOS_Sessions_UpdateSessionModification(InnerHandle, ref optionsInternal, out outSessionModificationHandleInnerHandle);

			Helper.Dispose(ref optionsInternal);

			Helper.Get(outSessionModificationHandleInnerHandle, out outSessionModificationHandle);

			return callResult;
		}
	}
}

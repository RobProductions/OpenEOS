// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.Mods
{
	public sealed partial class ModsInterface : Handle
	{
		public ModsInterface()
		{
		}

		public ModsInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="CopyModInfoOptions" /> API.
		/// </summary>
		public const int COPYMODINFO_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="EnumerateModsOptions" /> API.
		/// </summary>
		public const int ENUMERATEMODS_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="InstallMod" /> API.
		/// </summary>
		public const int INSTALLMOD_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="ModInfo" /> struct.
		/// </summary>
		public const int MODINFO_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="ModIdentifier" /> struct.
		/// </summary>
		public const int MOD_IDENTIFIER_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="UninstallModOptions" /> API.
		/// </summary>
		public const int UNINSTALLMOD_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="UpdateModOptions" /> API.
		/// </summary>
		public const int UPDATEMOD_API_LATEST = 1;

		/// <summary>
		/// Get cached enumerated mods object. If successful, this data must be released by calling <see cref="Release" />
		/// Types of the cached enumerated mods can be specified through <see cref="CopyModInfoOptions" />
		/// <see cref="Release" />
		/// This request may fail with an <see cref="Result.NotFound" /> code if an enumeration of a certain type was not performed before this call.
		/// </summary>
		/// <param name="options">
		/// structure containing the game identifier for which requesting enumerated mods
		/// </param>
		/// <param name="outEnumeratedMods">
		/// Enumerated mods Info. If the returned result is success, this will be set to data that must be later released, otherwise this will be set to <see langword="null" />
		/// </param>
		/// <returns>
		/// Success if we have cached data, or an error result if the request was invalid or we do not have cached data.
		/// </returns>
		public Result CopyModInfo(ref CopyModInfoOptions options, out ModInfo? outEnumeratedMods)
		{
			var optionsInternal = default(CopyModInfoOptionsInternal);
			optionsInternal.Set(ref options);

			var outEnumeratedModsPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Mods_CopyModInfo(InnerHandle, ref optionsInternal, out outEnumeratedModsPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<ModInfoInternal, ModInfo>(outEnumeratedModsPointer, out outEnumeratedMods);
			if (outEnumeratedModsPointer != IntPtr.Zero)
			{
				Bindings.EOS_Mods_ModInfo_Release(outEnumeratedModsPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Starts an asynchronous task that makes a request to enumerate mods for the specified game.
		/// Types of the mods to enumerate can be specified through <see cref="EnumerateModsOptions" />
		/// the section related to mods in eos_result.h for more details.
		/// </summary>
		/// <param name="options">
		/// structure containing the game identifiers
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void EnumerateMods(ref EnumerateModsOptions options, object clientData, OnEnumerateModsCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(EnumerateModsOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Mods_EnumerateMods(InnerHandle, ref optionsInternal, clientDataPointer, OnEnumerateModsCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Starts an asynchronous task that makes a request to install the specified mod.
		/// the section related to mods in eos_result.h for more details.
		/// </summary>
		/// <param name="options">
		/// structure containing the game and mod identifiers
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void InstallMod(ref InstallModOptions options, object clientData, OnInstallModCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(InstallModOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Mods_InstallMod(InnerHandle, ref optionsInternal, clientDataPointer, OnInstallModCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Starts an asynchronous task that makes a request to uninstall the specified mod.
		/// the section related to mods in eos_result.h for more details.
		/// </summary>
		/// <param name="options">
		/// structure containing the game and mod identifiers
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void UninstallMod(ref UninstallModOptions options, object clientData, OnUninstallModCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(UninstallModOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Mods_UninstallMod(InnerHandle, ref optionsInternal, clientDataPointer, OnUninstallModCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Starts an asynchronous task that makes a request to update the specified mod to the latest version.
		/// the section related to mods in eos_result.h for more details.
		/// </summary>
		/// <param name="options">
		/// structure containing the game and mod identifiers
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error. If the mod is up to date then the operation will complete with success.
		/// </param>
		public void UpdateMod(ref UpdateModOptions options, object clientData, OnUpdateModCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(UpdateModOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Mods_UpdateMod(InnerHandle, ref optionsInternal, clientDataPointer, OnUpdateModCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}
	}
}

// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.AntiCheatServer
{
	public sealed partial class AntiCheatServerInterface : Handle
	{
		public AntiCheatServerInterface()
		{
		}

		public AntiCheatServerInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		public const int ADDNOTIFYCLIENTACTIONREQUIRED_API_LATEST = 1;
		public const int ADDNOTIFYCLIENTAUTHSTATUSCHANGED_API_LATEST = 1;
		public const int ADDNOTIFYMESSAGETOCLIENT_API_LATEST = 1;
		public const int BEGINSESSION_API_LATEST = 3;
		public const int BEGINSESSION_MAX_REGISTERTIMEOUT = 120;
		/// <summary>
		/// Limits on RegisterTimeoutSeconds parameter
		/// </summary>
		public const int BEGINSESSION_MIN_REGISTERTIMEOUT = 10;
		public const int ENDSESSION_API_LATEST = 1;
		public const int GETPROTECTMESSAGEOUTPUTLENGTH_API_LATEST = 1;
		/// <summary>
		/// Maximum size of an individual message provided through <see cref="OnMessageToClientCallback" />.
		/// </summary>
		public const int ONMESSAGETOCLIENTCALLBACK_MAX_MESSAGE_SIZE = 512;
		public const int PROTECTMESSAGE_API_LATEST = 1;
		public const int RECEIVEMESSAGEFROMCLIENT_API_LATEST = 1;
		public const int REGISTERCLIENT_API_LATEST = 3;
		public const int SETCLIENTNETWORKSTATE_API_LATEST = 1;
		public const int UNPROTECTMESSAGE_API_LATEST = 1;
		public const int UNREGISTERCLIENT_API_LATEST = 1;

		/// <summary>
		/// Add a callback issued when an action must be applied to a connected client. The bound function
		/// will only be called between a successful call to <see cref="BeginSession" /> and the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data
		/// </param>
		/// <param name="clientData">
		/// This value is returned to the caller when NotificationFn is invoked
		/// </param>
		/// <param name="notificationFn">
		/// The callback to be fired
		/// </param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.INVALID_NOTIFICATIONID" /> otherwise
		/// </returns>
		public ulong AddNotifyClientActionRequired(ref AddNotifyClientActionRequiredOptions options, object clientData, OnClientActionRequiredCallback notificationFn)
		{
			if (notificationFn == null)
			{
				throw new ArgumentNullException("notificationFn");
			}

			var optionsInternal = default(AddNotifyClientActionRequiredOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notificationFn);

			var callResult = Bindings.EOS_AntiCheatServer_AddNotifyClientActionRequired(InnerHandle, ref optionsInternal, clientDataPointer, OnClientActionRequiredCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Add an optional callback issued when a connected client's authentication status changes. The bound function
		/// will only be called between a successful call to <see cref="BeginSession" /> and the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data
		/// </param>
		/// <param name="clientData">
		/// This value is returned to the caller when NotificationFn is invoked
		/// </param>
		/// <param name="notificationFn">
		/// The callback to be fired
		/// </param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.INVALID_NOTIFICATIONID" /> otherwise
		/// </returns>
		public ulong AddNotifyClientAuthStatusChanged(ref AddNotifyClientAuthStatusChangedOptions options, object clientData, OnClientAuthStatusChangedCallback notificationFn)
		{
			if (notificationFn == null)
			{
				throw new ArgumentNullException("notificationFn");
			}

			var optionsInternal = default(AddNotifyClientAuthStatusChangedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notificationFn);

			var callResult = Bindings.EOS_AntiCheatServer_AddNotifyClientAuthStatusChanged(InnerHandle, ref optionsInternal, clientDataPointer, OnClientAuthStatusChangedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Add a callback issued when a new message must be dispatched to a connected client. The bound function
		/// will only be called between a successful call to <see cref="BeginSession" /> and the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data
		/// </param>
		/// <param name="clientData">
		/// This value is returned to the caller when NotificationFn is invoked
		/// </param>
		/// <param name="notificationFn">
		/// The callback to be fired
		/// </param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.INVALID_NOTIFICATIONID" /> otherwise
		/// </returns>
		public ulong AddNotifyMessageToClient(ref AddNotifyMessageToClientOptions options, object clientData, OnMessageToClientCallback notificationFn)
		{
			if (notificationFn == null)
			{
				throw new ArgumentNullException("notificationFn");
			}

			var optionsInternal = default(AddNotifyMessageToClientOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notificationFn);

			var callResult = Bindings.EOS_AntiCheatServer_AddNotifyMessageToClient(InnerHandle, ref optionsInternal, clientDataPointer, OnMessageToClientCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Begin the gameplay session. Event callbacks must be configured with <see cref="AddNotifyMessageToClient" />
		/// and <see cref="AddNotifyClientActionRequired" /> before calling this function.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the initialization succeeded
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result BeginSession(ref BeginSessionOptions options)
		{
			var optionsInternal = default(BeginSessionOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_BeginSession(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// End the gameplay session. Should be called when the server is shutting down or entering an idle state.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the initialization succeeded
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result EndSession(ref EndSessionOptions options)
		{
			var optionsInternal = default(EndSessionOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_EndSession(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional NetProtect feature for game message encryption.
		/// Calculates the required decrypted buffer size for a given input data length.
		/// This will not change for a given SDK version, and allows one time allocation of reusable buffers.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <param name="">
		/// On success, the OutBuffer length in bytes that is required to call ProtectMessage on the given input size.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the output length was calculated successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result GetProtectMessageOutputLength(ref GetProtectMessageOutputLengthOptions options, out uint outBufferSizeBytes)
		{
			var optionsInternal = default(GetProtectMessageOutputLengthOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_GetProtectMessageOutputLength(InnerHandle, ref optionsInternal, out outBufferSizeBytes);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a custom gameplay event.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.NotConfigured" /> - If called outside of BeginSession/EndSession boundaries
		/// </returns>
		public Result LogEvent(ref AntiCheatCommon.LogEventOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.LogEventOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_LogEvent(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a game round's end and outcome.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.NotConfigured" /> - If called outside of BeginSession/EndSession boundaries
		/// </returns>
		public Result LogGameRoundEnd(ref AntiCheatCommon.LogGameRoundEndOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.LogGameRoundEndOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_LogGameRoundEnd(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a new game round start.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.NotConfigured" /> - If called outside of BeginSession/EndSession boundaries
		/// </returns>
		public Result LogGameRoundStart(ref AntiCheatCommon.LogGameRoundStartOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.LogGameRoundStartOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_LogGameRoundStart(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a player despawning in the game, for example as a result of the character's death,
		/// switching to spectator mode, etc.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.NotConfigured" /> - If called outside of BeginSession/EndSession boundaries
		/// </returns>
		public Result LogPlayerDespawn(ref AntiCheatCommon.LogPlayerDespawnOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.LogPlayerDespawnOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_LogPlayerDespawn(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a player being revived after being downed (see <see cref="LogPlayerTakeDamage" /> options).
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.NotConfigured" /> - If called outside of BeginSession/EndSession boundaries
		/// </returns>
		public Result LogPlayerRevive(ref AntiCheatCommon.LogPlayerReviveOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.LogPlayerReviveOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_LogPlayerRevive(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a player spawning into the game.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.NotConfigured" /> - If called outside of BeginSession/EndSession boundaries
		/// </returns>
		public Result LogPlayerSpawn(ref AntiCheatCommon.LogPlayerSpawnOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.LogPlayerSpawnOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_LogPlayerSpawn(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs that a player has taken damage.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.NotConfigured" /> - If called outside of BeginSession/EndSession boundaries
		/// </returns>
		public Result LogPlayerTakeDamage(ref AntiCheatCommon.LogPlayerTakeDamageOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.LogPlayerTakeDamageOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_LogPlayerTakeDamage(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs a player's general state including position and view direction.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.NotConfigured" /> - If called outside of BeginSession/EndSession boundaries
		/// </returns>
		public Result LogPlayerTick(ref AntiCheatCommon.LogPlayerTickOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.LogPlayerTickOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_LogPlayerTick(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs that a player has used a special ability or item which affects their character's capabilities,
		/// for example temporarily increasing their speed or allowing them to see nearby players behind walls.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.NotConfigured" /> - If called outside of BeginSession/EndSession boundaries
		/// </returns>
		public Result LogPlayerUseAbility(ref AntiCheatCommon.LogPlayerUseAbilityOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.LogPlayerUseAbilityOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_LogPlayerUseAbility(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Logs that a player has used a weapon, for example firing one bullet or making one melee attack.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was logged successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.NotConfigured" /> - If called outside of BeginSession/EndSession boundaries
		/// </returns>
		public Result LogPlayerUseWeapon(ref AntiCheatCommon.LogPlayerUseWeaponOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.LogPlayerUseWeaponOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_LogPlayerUseWeapon(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional NetProtect feature for game message encryption.
		/// Encrypts an arbitrary message that will be sent to a game client and decrypted on the other side.
		/// 
		/// Options.Data and OutBuffer may refer to the same buffer to encrypt in place.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <param name="outBuffer">
		/// On success, buffer where encrypted message data will be written.
		/// </param>
		/// <param name="outBytesWritten">
		/// On success, the number of bytes that were written to OutBuffer.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the message was protected successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.InvalidUser" /> - If the specified ClientHandle was invalid or not currently registered. See RegisterClient.
		/// </returns>
		public Result ProtectMessage(ref ProtectMessageOptions options, ArraySegment<byte> outBuffer, out uint outBytesWritten)
		{
			var optionsInternal = default(ProtectMessageOptionsInternal);
			optionsInternal.Set(ref options);

			var outBufferPointer = Helper.AddPinnedBuffer(outBuffer);

			var callResult = Bindings.EOS_AntiCheatServer_ProtectMessage(InnerHandle, ref optionsInternal, outBufferPointer, out outBytesWritten);

			Helper.Dispose(ref optionsInternal);

			Helper.Dispose(ref outBufferPointer);

			return callResult;
		}

		/// <summary>
		/// Call when an anti-cheat message is received from a client.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the message was processed successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// <see cref="Result.InvalidRequest" /> - If message contents were corrupt and could not be processed
		/// </returns>
		public Result ReceiveMessageFromClient(ref ReceiveMessageFromClientOptions options)
		{
			var optionsInternal = default(ReceiveMessageFromClientOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_ReceiveMessageFromClient(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Register a connected client. Must be paired with a call to UnregisterClient.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the player was registered successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result RegisterClient(ref RegisterClientOptions options)
		{
			var optionsInternal = default(RegisterClientOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_RegisterClient(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional Cerberus feature for gameplay data collection.
		/// Registers a custom gameplay event.
		/// 
		/// All custom game events must be registered before <see cref="BeginSession" /> is called for the first time.
		/// After the first call to <see cref="BeginSession" />, this function cannot be called any longer.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the event was registered successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result RegisterEvent(ref AntiCheatCommon.RegisterEventOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.RegisterEventOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_RegisterEvent(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Remove a previously bound <see cref="AddNotifyClientActionRequired" /> handler.
		/// </summary>
		/// <param name="notificationId">
		/// The previously bound notification ID
		/// </param>
		public void RemoveNotifyClientActionRequired(ulong notificationId)
		{
			Bindings.EOS_AntiCheatServer_RemoveNotifyClientActionRequired(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Remove a previously bound <see cref="AddNotifyClientAuthStatusChanged" /> handler.
		/// </summary>
		/// <param name="notificationId">
		/// The previously bound notification ID
		/// </param>
		public void RemoveNotifyClientAuthStatusChanged(ulong notificationId)
		{
			Bindings.EOS_AntiCheatServer_RemoveNotifyClientAuthStatusChanged(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Remove a previously bound <see cref="AddNotifyMessageToClient" /> handler.
		/// </summary>
		/// <param name="notificationId">
		/// The previously bound notification ID
		/// </param>
		public void RemoveNotifyMessageToClient(ulong notificationId)
		{
			Bindings.EOS_AntiCheatServer_RemoveNotifyMessageToClient(InnerHandle, notificationId);

			Helper.RemoveCallbackByNotificationId(notificationId);
		}

		/// <summary>
		/// Optional. Sets or updates client details including input device and admin status.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the flags were updated successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result SetClientDetails(ref AntiCheatCommon.SetClientDetailsOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.SetClientDetailsOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_SetClientDetails(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional. Can be used to indicate that a client is legitimately known to be
		/// temporarily unable to communicate, for example as a result of loading a new level.
		/// 
		/// The bIsNetworkActive flag must be set back to <see langword="true" /> when users enter normal
		/// gameplay, otherwise anti-cheat enforcement will not work correctly.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the network state was updated successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result SetClientNetworkState(ref SetClientNetworkStateOptions options)
		{
			var optionsInternal = default(SetClientNetworkStateOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_SetClientNetworkState(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional. Sets or updates a game session identifier which can be attached to other data for reference.
		/// The identifier can be updated at any time for currently and subsequently registered clients.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the game session identifier was set successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result SetGameSessionId(ref AntiCheatCommon.SetGameSessionIdOptions options)
		{
			var optionsInternal = default(AntiCheatCommon.SetGameSessionIdOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_SetGameSessionId(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Optional NetProtect feature for game message encryption.
		/// Decrypts an encrypted message received from a game client.
		/// 
		/// Options.Data and OutBuffer may refer to the same buffer to decrypt in place.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <param name="outBuffer">
		/// On success, buffer where encrypted message data will be written.
		/// </param>
		/// <param name="outBytesWritten">
		/// On success, the number of bytes that were written to OutBuffer.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the message was unprotected successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result UnprotectMessage(ref UnprotectMessageOptions options, ArraySegment<byte> outBuffer, out uint outBytesWritten)
		{
			var optionsInternal = default(UnprotectMessageOptionsInternal);
			optionsInternal.Set(ref options);

			var outBufferPointer = Helper.AddPinnedBuffer(outBuffer);

			var callResult = Bindings.EOS_AntiCheatServer_UnprotectMessage(InnerHandle, ref optionsInternal, outBufferPointer, out outBytesWritten);

			Helper.Dispose(ref optionsInternal);

			Helper.Dispose(ref outBufferPointer);

			return callResult;
		}

		/// <summary>
		/// Unregister a disconnected client.
		/// 
		/// This function may only be called between a successful call to <see cref="BeginSession" /> and
		/// the matching <see cref="EndSession" /> call.
		/// </summary>
		/// <param name="options">
		/// Structure containing input data.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> - If the player was unregistered successfully
		/// <see cref="Result.InvalidParameters" /> - If input data was invalid
		/// </returns>
		public Result UnregisterClient(ref UnregisterClientOptions options)
		{
			var optionsInternal = default(UnregisterClientOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_AntiCheatServer_UnregisterClient(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}
	}
}

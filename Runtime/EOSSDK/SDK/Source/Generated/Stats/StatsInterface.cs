// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.Stats
{
	public sealed partial class StatsInterface : Handle
	{
		public StatsInterface()
		{
		}

		public StatsInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="CopyStatByIndexOptions" /> struct.
		/// </summary>
		public const int COPYSTATBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyStatByNameOptions" /> struct.
		/// </summary>
		public const int COPYSTATBYNAME_API_LATEST = 1;
		/// <summary>
		/// DEPRECATED! Use <see cref="GETSTATSCOUNT_API_LATEST" /> instead.
		/// </summary>
		public const int GETSTATCOUNT_API_LATEST = GETSTATSCOUNT_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="GetStatsCount" /> API.
		/// </summary>
		public const int GETSTATSCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="IngestData" /> struct.
		/// </summary>
		public const int INGESTDATA_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="IngestStat" /> struct.
		/// </summary>
		public const int INGESTSTAT_API_LATEST = 3;
		/// <summary>
		/// Maximum number of stats that can be ingested in a single <see cref="IngestStat" /> operation.
		/// </summary>
		public const int MAX_INGEST_STATS = 3000;
		/// <summary>
		/// Maximum number of stats that can be queried in a single <see cref="QueryStats" /> operation.
		/// </summary>
		public const int MAX_QUERY_STATS = 1000;
		/// <summary>
		/// The most recent version of the <see cref="QueryStats" /> struct.
		/// </summary>
		public const int QUERYSTATS_API_LATEST = 3;
		/// <summary>
		/// The most recent version of the <see cref="Stat" /> struct.
		/// </summary>
		public const int STAT_API_LATEST = 1;
		/// <summary>
		/// Timestamp value representing an undefined StartTime or EndTime for <see cref="Stat" />
		/// </summary>
		public const int TIME_UNDEFINED = -1;

		/// <summary>
		/// Fetches a stat from a given index. Use <see cref="Release" /> when finished with the data.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the Product User ID and index being accessed
		/// </param>
		/// <param name="outStat">
		/// The stat data for the given index, if it exists and is valid
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutStat
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the stat is not found
		/// </returns>
		public Result CopyStatByIndex(ref CopyStatByIndexOptions options, out Stat? outStat)
		{
			var optionsInternal = default(CopyStatByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outStatPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Stats_CopyStatByIndex(InnerHandle, ref optionsInternal, out outStatPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<StatInternal, Stat>(outStatPointer, out outStat);
			if (outStatPointer != IntPtr.Zero)
			{
				Bindings.EOS_Stats_Stat_Release(outStatPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches a stat from cached stats by name. Use <see cref="Release" /> when finished with the data.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the Product User ID and name being accessed
		/// </param>
		/// <param name="outStat">
		/// The stat data for the given name, if it exists and is valid
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutStat
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the stat is not found
		/// </returns>
		public Result CopyStatByName(ref CopyStatByNameOptions options, out Stat? outStat)
		{
			var optionsInternal = default(CopyStatByNameOptionsInternal);
			optionsInternal.Set(ref options);

			var outStatPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Stats_CopyStatByName(InnerHandle, ref optionsInternal, out outStatPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<StatInternal, Stat>(outStatPointer, out outStat);
			if (outStatPointer != IntPtr.Zero)
			{
				Bindings.EOS_Stats_Stat_Release(outStatPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetch the number of stats that are cached locally.
		/// <see cref="CopyStatByIndex" />
		/// </summary>
		/// <param name="options">
		/// The Options associated with retrieving the stat count
		/// </param>
		/// <returns>
		/// Number of stats or 0 if there is an error
		/// </returns>
		public uint GetStatsCount(ref GetStatCountOptions options)
		{
			var optionsInternal = default(GetStatCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_Stats_GetStatsCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Ingest a stat by the amount specified in Options.
		/// When the operation is complete and the delegate is triggered the stat will be uploaded to the backend to be processed.
		/// The stat may not be updated immediately and an achievement using the stat may take a while to be unlocked once the stat has been uploaded.
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the stat we're ingesting.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="completionDelegate">
		/// This function is called when the ingest stat operation completes.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.InvalidUser" /> if target user ID is missing or incorrect
		/// </returns>
		public void IngestStat(ref IngestStatOptions options, object clientData, OnIngestStatCompleteCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(IngestStatOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Stats_IngestStat(InnerHandle, ref optionsInternal, clientDataPointer, OnIngestStatCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Query for a list of stats for a specific player.
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the player whose stats we're retrieving.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// This function is called when the query player stats operation completes.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation completes successfully
		/// <see cref="Result.InvalidParameters" /> if any of the options are incorrect
		/// <see cref="Result.InvalidUser" /> if target user ID is missing or incorrect
		/// </returns>
		public void QueryStats(ref QueryStatsOptions options, object clientData, OnQueryStatsCompleteCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryStatsOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Stats_QueryStats(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryStatsCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}
	}
}

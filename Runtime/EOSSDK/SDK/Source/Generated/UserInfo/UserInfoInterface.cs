// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.UserInfo
{
	public sealed partial class UserInfoInterface : Handle
	{
		public UserInfoInterface()
		{
		}

		public UserInfoInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="BestDisplayName" /> API.
		/// </summary>
		public const int BESTDISPLAYNAME_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyBestDisplayNameWithPlatform" /> API.
		/// </summary>
		public const int COPYBESTDISPLAYNAMEWITHPLATFORM_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyBestDisplayName" /> API.
		/// </summary>
		public const int COPYBESTDISPLAYNAME_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyExternalUserInfoByAccountIdOptions" /> struct.
		/// </summary>
		public const int COPYEXTERNALUSERINFOBYACCOUNTID_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyExternalUserInfoByIndexOptions" /> struct.
		/// </summary>
		public const int COPYEXTERNALUSERINFOBYACCOUNTTYPE_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyExternalUserInfoByIndexOptions" /> struct.
		/// </summary>
		public const int COPYEXTERNALUSERINFOBYINDEX_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyUserInfo" /> API.
		/// </summary>
		public const int COPYUSERINFO_API_LATEST = 3;
		/// <summary>
		/// The most recent version of the <see cref="ExternalUserInfo" /> struct.
		/// </summary>
		public const int EXTERNALUSERINFO_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="Achievements.AchievementsInterface.GetAchievementDefinitionCount" /> API.
		/// </summary>
		public const int GETEXTERNALUSERINFOCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="GetLocalPlatformType" /> API.
		/// </summary>
		public const int GETLOCALPLATFORMTYPE_API_LATEST = 1;
		/// <summary>
		/// The maximum length of display names, in displayable characters
		/// </summary>
		public const int MAX_DISPLAYNAME_CHARACTERS = 16;
		/// <summary>
		/// The maximum length of display names when encoded as UTF-8 as returned by <see cref="CopyUserInfo" />. This length does not include the <see langword="null" /> terminator.
		/// </summary>
		public const int MAX_DISPLAYNAME_UTF8_LENGTH = 64;
		/// <summary>
		/// The most recent version of the <see cref="QueryUserInfoByDisplayName" /> API.
		/// </summary>
		public const int QUERYUSERINFOBYDISPLAYNAME_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="QueryUserInfoByExternalAccount" /> API.
		/// </summary>
		public const int QUERYUSERINFOBYEXTERNALACCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="QueryUserInfo" /> API.
		/// </summary>
		public const int QUERYUSERINFO_API_LATEST = 1;

		/// <summary>
		/// <see cref="CopyBestDisplayName" /> is used to immediately retrieve a copy of user's best display name based on an Epic Account ID.
		/// This uses data cached by a previous call to <see cref="QueryUserInfo" />, <see cref="QueryUserInfoByDisplayName" /> or <see cref="QueryUserInfoByExternalAccount" /> as well as <see cref="Connect.ConnectInterface.QueryExternalAccountMappings" />.
		/// If the call returns an <see cref="Result.Success" /> result, the out parameter, OutBestDisplayName, must be passed to <see cref="Release" /> to release the memory associated with it.
		/// 
		/// @details The current priority for picking display name is as follows:
		/// 1. Target is online and friends with user, then use presence platform to determine display name
		/// 2. Target is in same lobby or is the owner of a lobby search result, then use lobby platform to determine display name (this requires the target's product user id to be cached)
		/// 3. Target is in same rtc room, then use rtc room platform to determine display name (this requires the target's product user id to be cached)
		/// <see cref="QueryUserInfo" />
		/// <see cref="QueryUserInfoByDisplayName" />
		/// <see cref="QueryUserInfoByExternalAccount" />
		/// <see cref="Connect.ConnectInterface.QueryExternalAccountMappings" />
		/// <see cref="CopyBestDisplayNameWithPlatform" />
		/// <see cref="CopyBestDisplayNameOptions" />
		/// <see cref="BestDisplayName" />
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// structure containing the input parameters
		/// </param>
		/// <param name="outBestDisplayName">
		/// out parameter used to receive the <see cref="BestDisplayName" /> structure.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutBestDisplayName
		/// <see cref="Result.UserInfoBestDisplayNameIndeterminate" /> unable to determine a cert friendly display name for user, one potential solution would be to call <see cref="CopyBestDisplayNameWithPlatform" /> with <see cref="Common.OPT_EPIC" /> for the platform, see doc for more details
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> if the user info or product user id is not locally cached
		/// </returns>
		public Result CopyBestDisplayName(ref CopyBestDisplayNameOptions options, out BestDisplayName? outBestDisplayName)
		{
			var optionsInternal = default(CopyBestDisplayNameOptionsInternal);
			optionsInternal.Set(ref options);

			var outBestDisplayNamePointer = IntPtr.Zero;

			var callResult = Bindings.EOS_UserInfo_CopyBestDisplayName(InnerHandle, ref optionsInternal, out outBestDisplayNamePointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<BestDisplayNameInternal, BestDisplayName>(outBestDisplayNamePointer, out outBestDisplayName);
			if (outBestDisplayNamePointer != IntPtr.Zero)
			{
				Bindings.EOS_UserInfo_BestDisplayName_Release(outBestDisplayNamePointer);
			}

			return callResult;
		}

		/// <summary>
		/// <see cref="CopyBestDisplayNameWithPlatform" /> is used to immediately retrieve a copy of user's best display name based on an Epic Account ID.
		/// This uses data cached by a previous call to <see cref="QueryUserInfo" />, <see cref="QueryUserInfoByDisplayName" /> or <see cref="QueryUserInfoByExternalAccount" />.
		/// If the call returns an <see cref="Result.Success" /> result, the out parameter, OutBestDisplayName, must be passed to <see cref="Release" /> to release the memory associated with it.
		/// 
		/// @details The current priority for picking display name is as follows:
		/// 1. If platform is non-epic, then use platform display name (if the platform is linked to the account)
		/// 2. If platform is epic and user has epic display name, then use epic display name
		/// 3. If platform is epic and user has no epic display name, then use linked external account display name
		/// <see cref="QueryUserInfo" />
		/// <see cref="QueryUserInfoByDisplayName" />
		/// <see cref="QueryUserInfoByExternalAccount" />
		/// <see cref="CopyBestDisplayNameWithPlatformOptions" />
		/// <see cref="BestDisplayName" />
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// structure containing the input parameters
		/// </param>
		/// <param name="outBestDisplayName">
		/// out parameter used to receive the <see cref="BestDisplayName" /> structure.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutBestDisplayName
		/// <see cref="Result.UserInfoBestDisplayNameIndeterminate" /> unable to determine a cert friendly display name for user
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> if the user info is not locally cached
		/// </returns>
		public Result CopyBestDisplayNameWithPlatform(ref CopyBestDisplayNameWithPlatformOptions options, out BestDisplayName? outBestDisplayName)
		{
			var optionsInternal = default(CopyBestDisplayNameWithPlatformOptionsInternal);
			optionsInternal.Set(ref options);

			var outBestDisplayNamePointer = IntPtr.Zero;

			var callResult = Bindings.EOS_UserInfo_CopyBestDisplayNameWithPlatform(InnerHandle, ref optionsInternal, out outBestDisplayNamePointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<BestDisplayNameInternal, BestDisplayName>(outBestDisplayNamePointer, out outBestDisplayName);
			if (outBestDisplayNamePointer != IntPtr.Zero)
			{
				Bindings.EOS_UserInfo_BestDisplayName_Release(outBestDisplayNamePointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches an external user info for a given external account ID.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the account ID being accessed
		/// </param>
		/// <param name="outExternalUserInfo">
		/// The external user info. If it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalUserInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the external user info is not found
		/// </returns>
		public Result CopyExternalUserInfoByAccountId(ref CopyExternalUserInfoByAccountIdOptions options, out ExternalUserInfo? outExternalUserInfo)
		{
			var optionsInternal = default(CopyExternalUserInfoByAccountIdOptionsInternal);
			optionsInternal.Set(ref options);

			var outExternalUserInfoPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_UserInfo_CopyExternalUserInfoByAccountId(InnerHandle, ref optionsInternal, out outExternalUserInfoPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<ExternalUserInfoInternal, ExternalUserInfo>(outExternalUserInfoPointer, out outExternalUserInfo);
			if (outExternalUserInfoPointer != IntPtr.Zero)
			{
				Bindings.EOS_UserInfo_ExternalUserInfo_Release(outExternalUserInfoPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches an external user info for a given external account type.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the account type being accessed
		/// </param>
		/// <param name="outExternalUserInfo">
		/// The external user info. If it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalUserInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the external user info is not found
		/// </returns>
		public Result CopyExternalUserInfoByAccountType(ref CopyExternalUserInfoByAccountTypeOptions options, out ExternalUserInfo? outExternalUserInfo)
		{
			var optionsInternal = default(CopyExternalUserInfoByAccountTypeOptionsInternal);
			optionsInternal.Set(ref options);

			var outExternalUserInfoPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_UserInfo_CopyExternalUserInfoByAccountType(InnerHandle, ref optionsInternal, out outExternalUserInfoPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<ExternalUserInfoInternal, ExternalUserInfo>(outExternalUserInfoPointer, out outExternalUserInfo);
			if (outExternalUserInfoPointer != IntPtr.Zero)
			{
				Bindings.EOS_UserInfo_ExternalUserInfo_Release(outExternalUserInfoPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetches an external user info from a given index.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the index being accessed
		/// </param>
		/// <param name="outExternalUserInfo">
		/// The external user info. If it exists and is valid, use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalUserInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the external user info is not found
		/// </returns>
		public Result CopyExternalUserInfoByIndex(ref CopyExternalUserInfoByIndexOptions options, out ExternalUserInfo? outExternalUserInfo)
		{
			var optionsInternal = default(CopyExternalUserInfoByIndexOptionsInternal);
			optionsInternal.Set(ref options);

			var outExternalUserInfoPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_UserInfo_CopyExternalUserInfoByIndex(InnerHandle, ref optionsInternal, out outExternalUserInfoPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<ExternalUserInfoInternal, ExternalUserInfo>(outExternalUserInfoPointer, out outExternalUserInfo);
			if (outExternalUserInfoPointer != IntPtr.Zero)
			{
				Bindings.EOS_UserInfo_ExternalUserInfo_Release(outExternalUserInfoPointer);
			}

			return callResult;
		}

		/// <summary>
		/// <see cref="CopyUserInfo" /> is used to immediately retrieve a copy of user information based on an Epic Account ID, cached by a previous call to <see cref="QueryUserInfo" />.
		/// If the call returns an <see cref="Result.Success" /> result, the out parameter, OutUserInfo, must be passed to <see cref="Release" /> to release the memory associated with it.
		/// <see cref="UserInfoData" />
		/// <see cref="CopyUserInfoOptions" />
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// structure containing the input parameters
		/// </param>
		/// <param name="outUserInfo">
		/// out parameter used to receive the <see cref="UserInfoData" /> structure.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.IncompatibleVersion" /> if the API version passed in is incorrect
		/// <see cref="Result.NotFound" /> if the user info is not locally cached. The information must have been previously cached by a call to <see cref="QueryUserInfo" />
		/// </returns>
		public Result CopyUserInfo(ref CopyUserInfoOptions options, out UserInfoData? outUserInfo)
		{
			var optionsInternal = default(CopyUserInfoOptionsInternal);
			optionsInternal.Set(ref options);

			var outUserInfoPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_UserInfo_CopyUserInfo(InnerHandle, ref optionsInternal, out outUserInfoPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<UserInfoDataInternal, UserInfoData>(outUserInfoPointer, out outUserInfo);
			if (outUserInfoPointer != IntPtr.Zero)
			{
				Bindings.EOS_UserInfo_Release(outUserInfoPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetch the number of external user infos that are cached locally.
		/// <see cref="CopyExternalUserInfoByIndex" />
		/// </summary>
		/// <param name="options">
		/// The options associated with retrieving the external user info count
		/// </param>
		/// <returns>
		/// The number of external user infos, or 0 if there is an error
		/// </returns>
		public uint GetExternalUserInfoCount(ref GetExternalUserInfoCountOptions options)
		{
			var optionsInternal = default(GetExternalUserInfoCountOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_UserInfo_GetExternalUserInfoCount(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// <see cref="GetLocalPlatformType" /> is used to retrieve the online platform type of the current running instance of the game.
		/// <see cref="GetLocalPlatformTypeOptions" />
		/// </summary>
		/// <param name="options">
		/// structure containing the input parameters
		/// </param>
		/// <returns>
		/// the online platform type of the current running instance of the game
		/// </returns>
		public uint GetLocalPlatformType(ref GetLocalPlatformTypeOptions options)
		{
			var optionsInternal = default(GetLocalPlatformTypeOptionsInternal);
			optionsInternal.Set(ref options);

			var callResult = Bindings.EOS_UserInfo_GetLocalPlatformType(InnerHandle, ref optionsInternal);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// <see cref="QueryUserInfo" /> is used to start an asynchronous query to retrieve information, such as display name, about another account.
		/// Once the callback has been fired with a successful ResultCode, it is possible to call <see cref="CopyUserInfo" /> to receive an <see cref="UserInfoData" /> containing the available information.
		/// <see cref="UserInfoData" />
		/// <see cref="CopyUserInfo" />
		/// <see cref="QueryUserInfoOptions" />
		/// <see cref="OnQueryUserInfoCallback" />
		/// </summary>
		/// <param name="options">
		/// structure containing the input parameters
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void QueryUserInfo(ref QueryUserInfoOptions options, object clientData, OnQueryUserInfoCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryUserInfoOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_UserInfo_QueryUserInfo(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryUserInfoCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// <see cref="QueryUserInfoByDisplayName" /> is used to start an asynchronous query to retrieve user information by display name. This can be useful for getting the <see cref="EpicAccountId" /> for a display name.
		/// Once the callback has been fired with a successful ResultCode, it is possible to call <see cref="CopyUserInfo" /> to receive an <see cref="UserInfoData" /> containing the available information.
		/// <see cref="UserInfoData" />
		/// <see cref="CopyUserInfo" />
		/// <see cref="QueryUserInfoByDisplayNameOptions" />
		/// <see cref="OnQueryUserInfoByDisplayNameCallback" />
		/// </summary>
		/// <param name="options">
		/// structure containing the input parameters
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void QueryUserInfoByDisplayName(ref QueryUserInfoByDisplayNameOptions options, object clientData, OnQueryUserInfoByDisplayNameCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryUserInfoByDisplayNameOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_UserInfo_QueryUserInfoByDisplayName(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryUserInfoByDisplayNameCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// <see cref="QueryUserInfoByExternalAccount" /> is used to start an asynchronous query to retrieve user information by external accounts.
		/// This can be useful for getting the <see cref="EpicAccountId" /> for external accounts.
		/// Once the callback has been fired with a successful ResultCode, it is possible to call CopyUserInfo to receive an <see cref="UserInfoData" /> containing the available information.
		/// <see cref="UserInfoData" />
		/// <see cref="QueryUserInfoByExternalAccountOptions" />
		/// <see cref="OnQueryUserInfoByExternalAccountCallback" />
		/// </summary>
		/// <param name="options">
		/// structure containing the input parameters
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the async operation completes, either successfully or in error
		/// </param>
		public void QueryUserInfoByExternalAccount(ref QueryUserInfoByExternalAccountOptions options, object clientData, OnQueryUserInfoByExternalAccountCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryUserInfoByExternalAccountOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_UserInfo_QueryUserInfoByExternalAccount(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryUserInfoByExternalAccountCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}
	}
}

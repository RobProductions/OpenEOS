// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.PlayerDataStorage
{
	public sealed partial class PlayerDataStorageInterface : Handle
	{
		public PlayerDataStorageInterface()
		{
		}

		public PlayerDataStorageInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// DEPRECATED! Use <see cref="COPYFILEMETADATAATINDEX_API_LATEST" /> instead.
		/// </summary>
		public const int COPYFILEMETADATAATINDEXOPTIONS_API_LATEST = COPYFILEMETADATAATINDEX_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="CopyFileMetadataAtIndex" /> API.
		/// </summary>
		public const int COPYFILEMETADATAATINDEX_API_LATEST = 1;
		/// <summary>
		/// DEPRECATED! Use <see cref="COPYFILEMETADATABYFILENAME_API_LATEST" /> instead.
		/// </summary>
		public const int COPYFILEMETADATABYFILENAMEOPTIONS_API_LATEST = COPYFILEMETADATABYFILENAME_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="CopyFileMetadataByFilename" /> API.
		/// </summary>
		public const int COPYFILEMETADATABYFILENAME_API_LATEST = 1;
		/// <summary>
		/// DEPRECATED! Use <see cref="DELETECACHE_API_LATEST" /> instead.
		/// </summary>
		public const int DELETECACHEOPTIONS_API_LATEST = DELETECACHE_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="DeleteCache" /> API.
		/// </summary>
		public const int DELETECACHE_API_LATEST = 1;
		/// <summary>
		/// DEPRECATED! Use <see cref="DELETEFILE_API_LATEST" /> instead.
		/// </summary>
		public const int DELETEFILEOPTIONS_API_LATEST = DELETEFILE_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="DeleteFile" /> API.
		/// </summary>
		public const int DELETEFILE_API_LATEST = 1;
		/// <summary>
		/// DEPRECATED! Use <see cref="DUPLICATEFILE_API_LATEST" /> instead.
		/// </summary>
		public const int DUPLICATEFILEOPTIONS_API_LATEST = DUPLICATEFILE_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="DuplicateFile" /> API.
		/// </summary>
		public const int DUPLICATEFILE_API_LATEST = 1;
		public const int FILEMETADATA_API_LATEST = 3;
		/// <summary>
		/// Maximum File Name Length in bytes
		/// </summary>
		public const int FILENAME_MAX_LENGTH_BYTES = 64;
		/// <summary>
		/// DEPRECATED! Use <see cref="GETFILEMETADATACOUNT_API_LATEST" /> instead.
		/// </summary>
		public const int GETFILEMETADATACOUNTOPTIONS_API_LATEST = GETFILEMETADATACOUNT_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="GetFileMetadataCount" /> API.
		/// </summary>
		public const int GETFILEMETADATACOUNT_API_LATEST = 1;
		/// <summary>
		/// DEPRECATED! Use <see cref="QUERYFILELIST_API_LATEST" /> instead.
		/// </summary>
		public const int QUERYFILELISTOPTIONS_API_LATEST = QUERYFILELIST_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="QueryFileList" /> API.
		/// </summary>
		public const int QUERYFILELIST_API_LATEST = 2;
		/// <summary>
		/// DEPRECATED! Use <see cref="QUERYFILE_API_LATEST" /> instead.
		/// </summary>
		public const int QUERYFILEOPTIONS_API_LATEST = QUERYFILE_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="QueryFile" /> API.
		/// </summary>
		public const int QUERYFILE_API_LATEST = 1;
		/// <summary>
		/// DEPRECATED! Use <see cref="READFILE_API_LATEST" /> instead.
		/// </summary>
		public const int READFILEOPTIONS_API_LATEST = READFILE_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="ReadFile" /> API.
		/// </summary>
		public const int READFILE_API_LATEST = 2;
		/// <summary>
		/// Timestamp value representing an undefined time for Player Data Storage.
		/// </summary>
		public const int TIME_UNDEFINED = -1;
		/// <summary>
		/// DEPRECATED! Use <see cref="WRITEFILE_API_LATEST" /> instead.
		/// </summary>
		public const int WRITEFILEOPTIONS_API_LATEST = WRITEFILE_API_LATEST;
		/// <summary>
		/// The most recent version of the <see cref="WriteFile" /> API.
		/// </summary>
		public const int WRITEFILE_API_LATEST = 2;

		/// <summary>
		/// Get the cached copy of a file's metadata by index. The metadata will be for the last retrieved or successfully saved version, and will not include any local changes that have not been
		/// committed by calling SaveFile. The returned <see cref="IntPtr" /> must be released by the user when no longer needed.
		/// <see cref="GetFileMetadataCount" />
		/// <see cref="Release" />
		/// </summary>
		/// <param name="copyFileMetadataOptions">
		/// Object containing properties related to which user is requesting metadata, and at what index
		/// </param>
		/// <param name="outMetadata">
		/// A copy of the FileMetadata structure will be set if successful. This data must be released by calling <see cref="Release" />.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the requested metadata is currently cached, otherwise an error result explaining what went wrong
		/// </returns>
		public Result CopyFileMetadataAtIndex(ref CopyFileMetadataAtIndexOptions copyFileMetadataOptions, out FileMetadata? outMetadata)
		{
			var copyFileMetadataOptionsInternal = default(CopyFileMetadataAtIndexOptionsInternal);
			copyFileMetadataOptionsInternal.Set(ref copyFileMetadataOptions);

			var outMetadataPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_PlayerDataStorage_CopyFileMetadataAtIndex(InnerHandle, ref copyFileMetadataOptionsInternal, out outMetadataPointer);

			Helper.Dispose(ref copyFileMetadataOptionsInternal);

			Helper.Get<FileMetadataInternal, FileMetadata>(outMetadataPointer, out outMetadata);
			if (outMetadataPointer != IntPtr.Zero)
			{
				Bindings.EOS_PlayerDataStorage_FileMetadata_Release(outMetadataPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Create the cached copy of a file's metadata by filename. The metadata will be for the last retrieved or successfully saved version, and will not include any changes that have not
		/// completed writing. The returned <see cref="IntPtr" /> must be released by the user when no longer needed.
		/// </summary>
		/// <param name="copyFileMetadataOptions">
		/// Object containing properties related to which user is requesting metadata, and for which filename
		/// </param>
		/// <param name="outMetadata">
		/// A copy of the FileMetadata structure will be set if successful. This data must be released by calling <see cref="Release" />.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the metadata is currently cached, otherwise an error result explaining what went wrong
		/// </returns>
		public Result CopyFileMetadataByFilename(ref CopyFileMetadataByFilenameOptions copyFileMetadataOptions, out FileMetadata? outMetadata)
		{
			var copyFileMetadataOptionsInternal = default(CopyFileMetadataByFilenameOptionsInternal);
			copyFileMetadataOptionsInternal.Set(ref copyFileMetadataOptions);

			var outMetadataPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_PlayerDataStorage_CopyFileMetadataByFilename(InnerHandle, ref copyFileMetadataOptionsInternal, out outMetadataPointer);

			Helper.Dispose(ref copyFileMetadataOptionsInternal);

			Helper.Get<FileMetadataInternal, FileMetadata>(outMetadataPointer, out outMetadata);
			if (outMetadataPointer != IntPtr.Zero)
			{
				Bindings.EOS_PlayerDataStorage_FileMetadata_Release(outMetadataPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Clear previously cached file data. This operation will be done asynchronously. All cached files except those corresponding to the transfers in progress will be removed.
		/// Warning: Use this with care. Cache system generally tries to clear old and unused cached files from time to time. Unnecessarily clearing cache can degrade performance as SDK will have to re-download data.
		/// </summary>
		/// <param name="options">
		/// Object containing properties related to which user is deleting cache
		/// </param>
		/// <param name="clientData">
		/// Optional <see cref="IntPtr" /> to help clients track this request, that is returned in associated callbacks
		/// </param>
		/// <param name="completionCallback">
		/// This function is called when the delete cache operation completes
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation was started correctly, otherwise an error result explaining what went wrong
		/// </returns>
		public Result DeleteCache(ref DeleteCacheOptions options, object clientData, OnDeleteCacheCompleteCallback completionCallback)
		{
			if (completionCallback == null)
			{
				throw new ArgumentNullException("completionCallback");
			}

			var optionsInternal = default(DeleteCacheOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionCallback);

			var callResult = Bindings.EOS_PlayerDataStorage_DeleteCache(InnerHandle, ref optionsInternal, clientDataPointer, OnDeleteCacheCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			return callResult;
		}

		/// <summary>
		/// Deletes an existing file in the cloud. If successful, the file's data will be removed from our local cache.
		/// </summary>
		/// <param name="deleteOptions">
		/// Object containing properties related to which user is deleting the file, and what file name is
		/// </param>
		/// <param name="clientData">
		/// Optional <see cref="IntPtr" /> to help clients track this request, that is returned in the completion callback
		/// </param>
		/// <param name="completionCallback">
		/// This function is called when the delete operation completes
		/// </param>
		public void DeleteFile(ref DeleteFileOptions deleteOptions, object clientData, OnDeleteFileCompleteCallback completionCallback)
		{
			if (completionCallback == null)
			{
				throw new ArgumentNullException("completionCallback");
			}

			var deleteOptionsInternal = default(DeleteFileOptionsInternal);
			deleteOptionsInternal.Set(ref deleteOptions);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionCallback);

			Bindings.EOS_PlayerDataStorage_DeleteFile(InnerHandle, ref deleteOptionsInternal, clientDataPointer, OnDeleteFileCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref deleteOptionsInternal);
		}

		/// <summary>
		/// Copies the data of an existing file to a new filename. This action happens entirely on the server and will not upload the contents of the source destination file from the host. This
		/// function paired with a subsequent <see cref="DeleteFile" /> can be used to rename a file. If successful, the destination file's metadata will be updated in our local cache.
		/// </summary>
		/// <param name="duplicateOptions">
		/// Object containing properties related to which user is duplicating the file, and what the source and destination file names are
		/// </param>
		/// <param name="clientData">
		/// Optional <see cref="IntPtr" /> to help clients track this request, that is returned in the completion callback
		/// </param>
		/// <param name="completionCallback">
		/// This function is called when the duplicate operation completes
		/// </param>
		public void DuplicateFile(ref DuplicateFileOptions duplicateOptions, object clientData, OnDuplicateFileCompleteCallback completionCallback)
		{
			if (completionCallback == null)
			{
				throw new ArgumentNullException("completionCallback");
			}

			var duplicateOptionsInternal = default(DuplicateFileOptionsInternal);
			duplicateOptionsInternal.Set(ref duplicateOptions);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionCallback);

			Bindings.EOS_PlayerDataStorage_DuplicateFile(InnerHandle, ref duplicateOptionsInternal, clientDataPointer, OnDuplicateFileCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref duplicateOptionsInternal);
		}

		/// <summary>
		/// Get the count of files we have previously queried information for and files we have previously read from / written to.
		/// <see cref="CopyFileMetadataAtIndex" />
		/// </summary>
		/// <param name="getFileMetadataCountOptions">
		/// Object containing properties related to which user is requesting the metadata count
		/// </param>
		/// <param name="outFileMetadataCount">
		/// If successful, the count of metadata currently cached
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the input was valid, otherwise an error result explaining what went wrong
		/// </returns>
		public Result GetFileMetadataCount(ref GetFileMetadataCountOptions getFileMetadataCountOptions, out int outFileMetadataCount)
		{
			var getFileMetadataCountOptionsInternal = default(GetFileMetadataCountOptionsInternal);
			getFileMetadataCountOptionsInternal.Set(ref getFileMetadataCountOptions);

			var callResult = Bindings.EOS_PlayerDataStorage_GetFileMetadataCount(InnerHandle, ref getFileMetadataCountOptionsInternal, out outFileMetadataCount);

			Helper.Dispose(ref getFileMetadataCountOptionsInternal);

			return callResult;
		}

		/// <summary>
		/// Query a specific file's metadata, such as file names, size, and a MD5 hash of the data. This is not required before a file may be opened, saved, copied, or deleted. Once a file has
		/// been queried, its metadata will be available by the <see cref="CopyFileMetadataAtIndex" /> and <see cref="CopyFileMetadataByFilename" /> functions.
		/// <see cref="GetFileMetadataCount" />
		/// <see cref="CopyFileMetadataAtIndex" />
		/// <see cref="CopyFileMetadataByFilename" />
		/// </summary>
		/// <param name="queryFileOptions">
		/// Object containing properties related to which user is querying files, and what file is being queried
		/// </param>
		/// <param name="clientData">
		/// Optional <see cref="IntPtr" /> to help clients track this request, that is returned in the completion callback
		/// </param>
		/// <param name="completionCallback">
		/// This function is called when the query operation completes
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the query completes successfully and a file is found
		/// <see cref="Result.NotFound" /> if no file is found
		/// </returns>
		public void QueryFile(ref QueryFileOptions queryFileOptions, object clientData, OnQueryFileCompleteCallback completionCallback)
		{
			if (completionCallback == null)
			{
				throw new ArgumentNullException("completionCallback");
			}

			var queryFileOptionsInternal = default(QueryFileOptionsInternal);
			queryFileOptionsInternal.Set(ref queryFileOptions);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionCallback);

			Bindings.EOS_PlayerDataStorage_QueryFile(InnerHandle, ref queryFileOptionsInternal, clientDataPointer, OnQueryFileCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref queryFileOptionsInternal);
		}

		/// <summary>
		/// Query the file metadata, such as file names, size, and a MD5 hash of the data, for all files owned by this user for this application. This is not required before a file may be opened,
		/// saved, copied, or deleted.
		/// <see cref="GetFileMetadataCount" />
		/// <see cref="CopyFileMetadataAtIndex" />
		/// <see cref="CopyFileMetadataByFilename" />
		/// </summary>
		/// <param name="queryFileListOptions">
		/// Object containing properties related to which user is querying files
		/// </param>
		/// <param name="clientData">
		/// Optional <see cref="IntPtr" /> to help clients track this request, that is returned in the completion callback
		/// </param>
		/// <param name="completionCallback">
		/// This function is called when the query operation completes
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the query completes successfully (whether any files are found or not)
		/// </returns>
		public void QueryFileList(ref QueryFileListOptions queryFileListOptions, object clientData, OnQueryFileListCompleteCallback completionCallback)
		{
			if (completionCallback == null)
			{
				throw new ArgumentNullException("completionCallback");
			}

			var queryFileListOptionsInternal = default(QueryFileListOptionsInternal);
			queryFileListOptionsInternal.Set(ref queryFileListOptions);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionCallback);

			Bindings.EOS_PlayerDataStorage_QueryFileList(InnerHandle, ref queryFileListOptionsInternal, clientDataPointer, OnQueryFileListCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref queryFileListOptionsInternal);
		}

		/// <summary>
		/// Retrieve the contents of a specific file, potentially downloading the contents if we do not have a local copy, from the cloud. This request will occur asynchronously, potentially over
		/// multiple frames. All callbacks for this function will come from the same thread that the SDK is ticked from. If specified, the FileTransferProgressCallback will always be called at
		/// least once if the request is started successfully.
		/// <see cref="PlayerDataStorageFileTransferRequest.Release" />
		/// </summary>
		/// <param name="readOptions">
		/// Object containing properties related to which user is opening the file, what the file's name is, and related mechanisms for copying the data
		/// </param>
		/// <param name="clientData">
		/// Optional <see cref="IntPtr" /> to help clients track this request, that is returned in associated callbacks
		/// </param>
		/// <param name="completionCallback">
		/// This function is called when the read operation completes
		/// </param>
		/// <returns>
		/// A valid Player Data Storage File Request handle if successful, or <see langword="null" /> otherwise. Data contained in the completion callback will have more detailed information about issues with the request in failure cases. This handle must be released when it is no longer needed
		/// <see cref="Result.Success" /> if the file is exists and the read operation completes successfully
		/// <see cref="Result.NotFound" /> if no file is found
		/// </returns>
		public PlayerDataStorageFileTransferRequest ReadFile(ref ReadFileOptions readOptions, object clientData, OnReadFileCompleteCallback completionCallback)
		{
			if (completionCallback == null)
			{
				throw new ArgumentNullException("completionCallback");
			}

			var readOptionsInternal = default(ReadFileOptionsInternal);
			readOptionsInternal.Set(ref readOptions);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionCallback);

			Helper.AddCallback(clientDataPointer, readOptions.ReadFileDataCallback);
			Helper.AddCallback(clientDataPointer, readOptions.FileTransferProgressCallback);

			var callResult = Bindings.EOS_PlayerDataStorage_ReadFile(InnerHandle, ref readOptionsInternal, clientDataPointer, OnReadFileCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref readOptionsInternal);

			PlayerDataStorageFileTransferRequest callResultReturn;
			Helper.Get(callResult, out callResultReturn);
			return callResultReturn;
		}

		/// <summary>
		/// Write new data to a specific file, potentially overwriting any existing file by the same name, to the cloud. This request will occur asynchronously, potentially over multiple frames.
		/// All callbacks for this function will come from the same thread that the SDK is ticked from. If specified, the FileTransferProgressCallback will always be called at least once if the
		/// request is started successfully.
		/// <see cref="PlayerDataStorageFileTransferRequest.Release" />
		/// </summary>
		/// <param name="writeOptions">
		/// Object containing properties related to which user is writing the file, what the file's name is, and related mechanisms for writing the data
		/// </param>
		/// <param name="clientData">
		/// Optional <see cref="IntPtr" /> to help clients track this request, that is returned in associated callbacks
		/// </param>
		/// <param name="completionCallback">
		/// This function is called when the write operation completes
		/// </param>
		/// <returns>
		/// A valid Player Data Storage File Request handle if successful, or <see langword="null" /> otherwise. Data contained in the completion callback will have more detailed information about issues with the request in failure cases. This handle must be released when it is no longer needed
		/// </returns>
		public PlayerDataStorageFileTransferRequest WriteFile(ref WriteFileOptions writeOptions, object clientData, OnWriteFileCompleteCallback completionCallback)
		{
			if (completionCallback == null)
			{
				throw new ArgumentNullException("completionCallback");
			}

			var writeOptionsInternal = default(WriteFileOptionsInternal);
			writeOptionsInternal.Set(ref writeOptions);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionCallback);

			Helper.AddCallback(clientDataPointer, writeOptions.WriteFileDataCallback);
			Helper.AddCallback(clientDataPointer, writeOptions.FileTransferProgressCallback);

			var callResult = Bindings.EOS_PlayerDataStorage_WriteFile(InnerHandle, ref writeOptionsInternal, clientDataPointer, OnWriteFileCompleteCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref writeOptionsInternal);

			PlayerDataStorageFileTransferRequest callResultReturn;
			Helper.Get(callResult, out callResultReturn);
			return callResultReturn;
		}
	}
}

// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;

namespace Epic.OnlineServices.Auth
{
	public sealed partial class AuthInterface : Handle
	{
		public AuthInterface()
		{
		}

		public AuthInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="AccountFeatureRestrictedInfo" /> struct.
		/// </summary>
		public const int ACCOUNTFEATURERESTRICTEDINFO_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLoginStatusChanged" /> API.
		/// </summary>
		public const int ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyIdToken" /> API.
		/// </summary>
		public const int COPYIDTOKEN_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="CopyUserAuthToken" /> API.
		/// </summary>
		public const int COPYUSERAUTHTOKEN_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="Credentials" /> struct.
		/// </summary>
		public const int CREDENTIALS_API_LATEST = 4;
		/// <summary>
		/// The most recent version of the <see cref="DeletePersistentAuth" /> API.
		/// </summary>
		public const int DELETEPERSISTENTAUTH_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="IdToken" /> struct.
		/// </summary>
		public const int IDTOKEN_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="LinkAccount" /> API.
		/// </summary>
		public const int LINKACCOUNT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="Login" /> API.
		/// </summary>
		public const int LOGIN_API_LATEST = 3;
		/// <summary>
		/// The most recent version of the <see cref="Logout" /> API.
		/// </summary>
		public const int LOGOUT_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="PinGrantInfo" /> struct.
		/// </summary>
		public const int PINGRANTINFO_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="QueryIdToken" /> API.
		/// </summary>
		public const int QUERYIDTOKEN_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="Token" /> struct.
		/// </summary>
		public const int TOKEN_API_LATEST = 2;
		/// <summary>
		/// The most recent version of the <see cref="VerifyIdToken" /> API.
		/// </summary>
		public const int VERIFYIDTOKEN_API_LATEST = 1;
		/// <summary>
		/// The most recent version of the <see cref="VerifyUserAuth" /> API.
		/// </summary>
		public const int VERIFYUSERAUTH_API_LATEST = 1;

		/// <summary>
		/// Register to receive login status updates.
		/// If the returned NotificationId is valid, you must call <see cref="RemoveNotifyLoginStatusChanged" /> when you no longer wish to have your NotificationHandler called.
		/// </summary>
		/// <param name="options">
		/// structure containing the api version of AddNotifyLoginStatusChanged to use
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the callback
		/// </param>
		/// <param name="notification">
		/// a callback that is fired when the login status for a user changes
		/// </param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLoginStatusChanged(ref AddNotifyLoginStatusChangedOptions options, object clientData, OnLoginStatusChangedCallback notification)
		{
			if (notification == null)
			{
				throw new ArgumentNullException("notification");
			}

			var optionsInternal = default(AddNotifyLoginStatusChangedOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, notification);

			var callResult = Bindings.EOS_Auth_AddNotifyLoginStatusChanged(InnerHandle, ref optionsInternal, clientDataPointer, OnLoginStatusChangedCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);

			Helper.AssignNotificationIdToCallback(clientDataPointer, callResult);

			return callResult;
		}

		/// <summary>
		/// Fetch an ID token for an Epic Account ID.
		/// 
		/// ID tokens are used to securely verify user identities with online services.
		/// The most common use case is using an ID token to authenticate the local user by their selected account ID,
		/// which is the account ID that should be used to access any game-scoped data for the current application.
		/// 
		/// An ID token for the selected account ID of a locally authenticated user will always be readily available.
		/// To retrieve it for the selected account ID, you can use <see cref="CopyIdToken" /> directly after a successful user login.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the account ID for which to copy an ID token.
		/// </param>
		/// <param name="outIdToken">
		/// An ID token for the given user, if it exists and is valid; use <see cref="Release" /> when finished.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserIdToken
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the Id token is not found or expired.
		/// </returns>
		public Result CopyIdToken(ref CopyIdTokenOptions options, out IdToken? outIdToken)
		{
			var optionsInternal = default(CopyIdTokenOptionsInternal);
			optionsInternal.Set(ref options);

			var outIdTokenPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Auth_CopyIdToken(InnerHandle, ref optionsInternal, out outIdTokenPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<IdTokenInternal, IdToken>(outIdTokenPointer, out outIdToken);
			if (outIdTokenPointer != IntPtr.Zero)
			{
				Bindings.EOS_Auth_IdToken_Release(outIdTokenPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Fetch a user auth token for an Epic Account ID.
		/// 
		/// A user authentication token allows any code with possession (backend/client) to perform certain actions on behalf of the user.
		/// Because of this, for the purposes of user identity verification, the <see cref="CopyIdToken" /> API should be used instead.
		/// <see cref="Release" />
		/// </summary>
		/// <param name="options">
		/// Structure containing the api version of CopyUserAuthToken to use
		/// </param>
		/// <param name="localUserId">
		/// The Epic Account ID of the user being queried
		/// </param>
		/// <param name="outUserAuthToken">
		/// The auth token for the given user, if it exists and is valid; use <see cref="Release" /> when finished
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserAuthToken
		/// <see cref="Result.InvalidParameters" /> if you pass a <see langword="null" /> <see cref="IntPtr" /> for the out parameter
		/// <see cref="Result.NotFound" /> if the auth token is not found or expired.
		/// </returns>
		public Result CopyUserAuthToken(ref CopyUserAuthTokenOptions options, EpicAccountId localUserId, out Token? outUserAuthToken)
		{
			var optionsInternal = default(CopyUserAuthTokenOptionsInternal);
			optionsInternal.Set(ref options);

			var outUserAuthTokenPointer = IntPtr.Zero;

			var callResult = Bindings.EOS_Auth_CopyUserAuthToken(InnerHandle, ref optionsInternal, localUserId.InnerHandle, out outUserAuthTokenPointer);

			Helper.Dispose(ref optionsInternal);

			Helper.Get<TokenInternal, Token>(outUserAuthTokenPointer, out outUserAuthToken);
			if (outUserAuthTokenPointer != IntPtr.Zero)
			{
				Bindings.EOS_Auth_Token_Release(outUserAuthTokenPointer);
			}

			return callResult;
		}

		/// <summary>
		/// Deletes a previously received and locally stored persistent auth access token for the currently logged in user of the local device.
		/// 
		/// On Desktop and Mobile platforms, the access token is deleted from the keychain of the local user and a backend request is made to revoke the token on the authentication server.
		/// On Console platforms, even though the caller is responsible for storing and deleting the access token on the local device,
		/// this function should still be called with the access token before its deletion to make the best effort in attempting to also revoke it on the authentication server.
		/// If the function would fail on Console, the caller should still proceed as normal to delete the access token locally as intended.
		/// </summary>
		/// <param name="options">
		/// structure containing operation input parameters
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the deletion operation completes, either successfully or in error
		/// </param>
		public void DeletePersistentAuth(ref DeletePersistentAuthOptions options, object clientData, OnDeletePersistentAuthCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(DeletePersistentAuthOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Auth_DeletePersistentAuth(InnerHandle, ref optionsInternal, clientDataPointer, OnDeletePersistentAuthCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Fetch an Epic Account ID that is logged in.
		/// </summary>
		/// <param name="index">
		/// An index into the list of logged in accounts. If the index is out of bounds, the returned Epic Account ID will be invalid.
		/// </param>
		/// <returns>
		/// The Epic Account ID associated with the index passed
		/// </returns>
		public EpicAccountId GetLoggedInAccountByIndex(int index)
		{
			var callResult = Bindings.EOS_Auth_GetLoggedInAccountByIndex(InnerHandle, index);

			EpicAccountId callResultReturn;
			Helper.Get(callResult, out callResultReturn);
			return callResultReturn;
		}

		/// <summary>
		/// Fetch the number of accounts that are logged in.
		/// </summary>
		/// <returns>
		/// the number of accounts logged in.
		/// </returns>
		public int GetLoggedInAccountsCount()
		{
			var callResult = Bindings.EOS_Auth_GetLoggedInAccountsCount(InnerHandle);

			return callResult;
		}

		/// <summary>
		/// Fetches the login status for an Epic Account ID.
		/// </summary>
		/// <param name="localUserId">
		/// The Epic Account ID of the user being queried
		/// </param>
		/// <returns>
		/// The enum value of a user's login status
		/// </returns>
		public LoginStatus GetLoginStatus(EpicAccountId localUserId)
		{
			var callResult = Bindings.EOS_Auth_GetLoginStatus(InnerHandle, localUserId.InnerHandle);

			return callResult;
		}

		/// <summary>
		/// Fetch one of the merged account IDs for a given logged in account.
		/// </summary>
		/// <param name="localUserId">
		/// The account ID of a currently logged in account.
		/// </param>
		/// <param name="index">
		/// An index into the list of merged accounts. If the index is out of bounds, the returned Epic Account ID will be invalid.
		/// </param>
		/// <returns>
		/// The Epic Account ID associated with the index passed.
		/// </returns>
		public EpicAccountId GetMergedAccountByIndex(EpicAccountId localUserId, uint index)
		{
			var callResult = Bindings.EOS_Auth_GetMergedAccountByIndex(InnerHandle, localUserId.InnerHandle, index);

			EpicAccountId callResultReturn;
			Helper.Get(callResult, out callResultReturn);
			return callResultReturn;
		}

		/// <summary>
		/// Fetch the number of merged accounts for a given logged in account.
		/// </summary>
		/// <param name="localUserId">
		/// The account ID of a currently logged in account.
		/// </param>
		/// <returns>
		/// the number of merged accounts for the logged in account.
		/// </returns>
		public uint GetMergedAccountsCount(EpicAccountId localUserId)
		{
			var callResult = Bindings.EOS_Auth_GetMergedAccountsCount(InnerHandle, localUserId.InnerHandle);

			return callResult;
		}

		/// <summary>
		/// Fetch the selected account ID to the current application for a local authenticated user.
		/// </summary>
		/// <param name="localUserId">
		/// The account ID of a currently logged in account.
		/// </param>
		/// <param name="outSelectedAccountId">
		/// The selected account ID corresponding to the given account ID.
		/// </param>
		/// <returns>
		/// <see cref="Result.Success" /> if the user is logged in and the information is available.
		/// <see cref="Result.InvalidParameters" /> if the output parameter is <see langword="null" />.
		/// <see cref="Result.InvalidUser" /> if the input account ID is not locally known.
		/// <see cref="Result.InvalidAuth" /> if the input account ID is not locally logged in.
		/// <see cref="Result.NotFound" /> otherwise.
		/// </returns>
		public Result GetSelectedAccountId(EpicAccountId localUserId, out EpicAccountId outSelectedAccountId)
		{
			var outSelectedAccountIdInnerHandle = IntPtr.Zero;

			var callResult = Bindings.EOS_Auth_GetSelectedAccountId(InnerHandle, localUserId.InnerHandle, out outSelectedAccountIdInnerHandle);

			Helper.Get(outSelectedAccountIdInnerHandle, out outSelectedAccountId);

			return callResult;
		}

		/// <summary>
		/// Link external account by continuing previous login attempt with a continuance token.
		/// 
		/// The user will be presented with Epic Accounts onboarding flow managed by the SDK.
		/// 
		/// On success, the user will be logged in at the completion of this action.
		/// This will commit this external account to the Epic Account and cannot be undone in the SDK.
		/// </summary>
		/// <param name="options">
		/// structure containing the account credentials to use during the link account operation
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the link account operation completes, either successfully or in error
		/// </param>
		public void LinkAccount(ref LinkAccountOptions options, object clientData, OnLinkAccountCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(LinkAccountOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Auth_LinkAccount(InnerHandle, ref optionsInternal, clientDataPointer, OnLinkAccountCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Login/Authenticate with user credentials.
		/// </summary>
		/// <param name="options">
		/// structure containing the account credentials to use during the login operation
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the login operation completes, either successfully or in error
		/// </param>
		public void Login(ref LoginOptions options, object clientData, OnLoginCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(LoginOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Auth_Login(InnerHandle, ref optionsInternal, clientDataPointer, OnLoginCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Signs the player out of the online service.
		/// </summary>
		/// <param name="options">
		/// structure containing information about which account to log out.
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the logout operation completes, either successfully or in error
		/// </param>
		public void Logout(ref LogoutOptions options, object clientData, OnLogoutCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(LogoutOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Auth_Logout(InnerHandle, ref optionsInternal, clientDataPointer, OnLogoutCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Query the backend for an ID token that describes one of the merged account IDs of a local authenticated user.
		/// 
		/// The ID token can be used to impersonate a merged account ID when communicating with online services.
		/// 
		/// An ID token for the selected account ID of a locally authenticated user will always be readily available and does not need to be queried explicitly.
		/// </summary>
		/// <param name="options">
		/// Structure containing the merged account ID for which to query an ID token.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate.
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the operation completes, either successfully or in error.
		/// </param>
		public void QueryIdToken(ref QueryIdTokenOptions options, object clientData, OnQueryIdTokenCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(QueryIdTokenOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Auth_QueryIdToken(InnerHandle, ref optionsInternal, clientDataPointer, OnQueryIdTokenCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Unregister from receiving login status updates.
		/// </summary>
		/// <param name="inId">
		/// handle representing the registered callback
		/// </param>
		public void RemoveNotifyLoginStatusChanged(ulong inId)
		{
			Bindings.EOS_Auth_RemoveNotifyLoginStatusChanged(InnerHandle, inId);

			Helper.RemoveCallbackByNotificationId(inId);
		}

		/// <summary>
		/// Verify a given ID token for authenticity and validity.
		/// </summary>
		/// <param name="options">
		/// Structure containing information about the ID token to verify.
		/// </param>
		/// <param name="clientData">
		/// Arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// A callback that is fired when the operation completes, either successfully or in error.
		/// </param>
		public void VerifyIdToken(ref VerifyIdTokenOptions options, object clientData, OnVerifyIdTokenCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(VerifyIdTokenOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Auth_VerifyIdToken(InnerHandle, ref optionsInternal, clientDataPointer, OnVerifyIdTokenCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}

		/// <summary>
		/// Contact the backend service to verify validity of an existing user auth token.
		/// This function is intended for server-side use only.
		/// <see cref="CopyUserAuthToken" />
		/// </summary>
		/// <param name="options">
		/// structure containing information about the auth token being verified
		/// </param>
		/// <param name="clientData">
		/// arbitrary data that is passed back to you in the CompletionDelegate
		/// </param>
		/// <param name="completionDelegate">
		/// a callback that is fired when the logout operation completes, either successfully or in error
		/// </param>
		public void VerifyUserAuth(ref VerifyUserAuthOptions options, object clientData, OnVerifyUserAuthCallback completionDelegate)
		{
			if (completionDelegate == null)
			{
				throw new ArgumentNullException("completionDelegate");
			}

			var optionsInternal = default(VerifyUserAuthOptionsInternal);
			optionsInternal.Set(ref options);

			var clientDataPointer = IntPtr.Zero;

			Helper.AddCallback(out clientDataPointer, clientData, completionDelegate);

			Bindings.EOS_Auth_VerifyUserAuth(InnerHandle, ref optionsInternal, clientDataPointer, OnVerifyUserAuthCallbackInternalImplementation.Delegate);

			Helper.Dispose(ref optionsInternal);
		}
	}
}
